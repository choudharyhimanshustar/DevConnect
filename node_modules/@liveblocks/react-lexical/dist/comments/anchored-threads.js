'use strict';

var jsxRuntime = require('react/jsx-runtime');
var LexicalComposerContext = require('@lexical/react/LexicalComposerContext');
var _private = require('@liveblocks/react/_private');
var reactUi = require('@liveblocks/react-ui');
var lexical = require('lexical');
var react = require('react');
var classnames = require('../classnames.js');
var useRootElement = require('../use-root-element.js');
var commentPluginProvider = require('./comment-plugin-provider.js');
var threadMarkNode = require('./thread-mark-node.js');

const DEFAULT_GAP = 20;
const DEFAULT_ACTIVE_THREAD_OFFSET = -12;
const GAP = `var(--lb-lexical-anchored-threads-gap, ${DEFAULT_GAP}px)`;
const ACTIVE_THREAD_OFFSET = `var(--lb-lexical-anchored-threads-active-thread-offset, ${DEFAULT_ACTIVE_THREAD_OFFSET}px)`;
function compareNodes(a, b) {
  const position = a.compareDocumentPosition(b);
  if (position & Node.DOCUMENT_POSITION_FOLLOWING)
    return -1;
  if (position & Node.DOCUMENT_POSITION_PRECEDING)
    return 1;
  return 0;
}
function AnchoredThreads({
  threads,
  components,
  className,
  style,
  ...props
}) {
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const Thread = components?.Thread ?? reactUi.Thread;
  const containerRef = react.useRef(null);
  const activeThreads = useActiveThreads();
  const nodes = useThreadToNodes();
  const getOrderedThreads = react.useCallback(() => {
    return threads.filter((thread) => thread.resolved === false).map((thread) => {
      const keys = nodes.get(thread.id);
      if (keys === void 0 || keys.size === 0)
        return null;
      const elements2 = Array.from(keys.values()).map((key) => editor.getElementByKey(key)).filter(Boolean);
      if (elements2.length === 0)
        return null;
      const element = elements2.sort(compareNodes)[0];
      return {
        thread,
        element
      };
    }).filter(
      (entry) => entry !== null
    ).sort((a, b) => {
      return compareNodes(a.element, b.element);
    });
  }, [editor, threads, nodes]);
  const orderedThreads = react.useMemo(getOrderedThreads, [getOrderedThreads]);
  const [elements, setElements] = react.useState(/* @__PURE__ */ new Map());
  const [positions, setPositions] = react.useState(/* @__PURE__ */ new Map());
  const onItemAdd = react.useCallback((id, el) => {
    setElements((prev) => new Map(prev).set(id, el));
  }, []);
  const onItemRemove = react.useCallback((id) => {
    setElements((prev) => {
      const items = new Map(prev);
      items.delete(id);
      return items;
    });
  }, []);
  const handlePositionThreads = react.useCallback(() => {
    const container = containerRef.current;
    if (container === null)
      return;
    const orderedThreads2 = getOrderedThreads();
    function getAscendingThreads() {
      if (activeThreads.length === 0)
        return orderedThreads2;
      const active = orderedThreads2.filter(
        ({ thread }) => activeThreads.includes(thread.id)
      );
      const after = orderedThreads2.filter(({ thread, element }) => {
        if (activeThreads.includes(thread.id))
          return false;
        const isAfter = active.some(({ element: activeElement }) => {
          return compareNodes(activeElement, element) === -1;
        });
        return isAfter;
      });
      return active.concat(after);
    }
    const ascending = getAscendingThreads();
    const descending = orderedThreads2.filter(
      (entry) => !ascending.includes(entry)
    );
    const newPositions = /* @__PURE__ */ new Map();
    for (const { thread, element } of ascending) {
      const rect = element.getBoundingClientRect();
      let top = rect.top - container.getBoundingClientRect().top;
      for (const [id, position] of newPositions) {
        const el = elements.get(id);
        if (el === void 0)
          continue;
        if (top >= position && top <= position + el.getBoundingClientRect().height) {
          top = position + el.getBoundingClientRect().height;
        }
      }
      newPositions.set(thread.id, top);
    }
    for (const { thread, element } of descending.reverse()) {
      const rect = element.getBoundingClientRect();
      const el = elements.get(thread.id);
      if (el === void 0)
        continue;
      let top = rect.top - container.getBoundingClientRect().top;
      for (const [, position] of newPositions) {
        if (top >= position - el.getBoundingClientRect().height) {
          top = position - el.getBoundingClientRect().height;
        }
      }
      newPositions.set(thread.id, top);
    }
    setPositions(newPositions);
  }, [getOrderedThreads, activeThreads, elements]);
  _private.useLayoutEffect(() => {
    handlePositionThreads();
  }, [handlePositionThreads]);
  react.useEffect(() => {
    return editor.registerUpdateListener(() => {
      handlePositionThreads();
    });
  }, [editor, handlePositionThreads]);
  react.useEffect(() => {
    const observer = new ResizeObserver(handlePositionThreads);
    for (const element of elements.values()) {
      observer.observe(element);
    }
    return () => observer.disconnect();
  }, [elements, handlePositionThreads]);
  const root = useRootElement.useRootElement();
  react.useEffect(() => {
    if (root === null)
      return;
    const observer = new ResizeObserver(handlePositionThreads);
    observer.observe(root);
    return () => observer.disconnect();
  }, [root, handlePositionThreads]);
  if (orderedThreads.length === 0)
    return null;
  return /* @__PURE__ */ jsxRuntime.jsx("div", {
    ...props,
    className: classnames.classNames(className, "lb-root lb-lexical-anchored-threads"),
    ref: containerRef,
    style: {
      position: "relative",
      ...style
    },
    children: orderedThreads.map(({ thread, element }) => {
      const rect = element.getBoundingClientRect();
      const offset = root !== null ? root.getBoundingClientRect().top : 0;
      let top = rect.top - offset;
      if (positions.has(thread.id)) {
        top = positions.get(thread.id);
      }
      const isActive = activeThreads.includes(thread.id);
      return /* @__PURE__ */ jsxRuntime.jsx(ThreadWrapper, {
        Thread,
        thread,
        onItemAdd,
        onItemRemove,
        style: {
          position: "absolute",
          transform: `translate3d(${isActive ? ACTIVE_THREAD_OFFSET : 0}, ${top}px, 0)`,
          insetInlineStart: 0,
          inlineSize: "100%",
          paddingBlockEnd: GAP
        }
      }, thread.id);
    })
  });
}
function ThreadWrapper({
  onItemAdd,
  onItemRemove,
  thread,
  Thread,
  className,
  ...props
}) {
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const nodes = useThreadToNodes();
  const divRef = react.useRef(null);
  const activeThreads = useActiveThreads();
  const isActive = activeThreads.includes(thread.id);
  function handleThreadClick() {
    const keys = nodes.get(thread.id);
    if (keys === void 0 || keys.size === 0)
      return;
    if (activeThreads.includes(thread.id))
      return;
    editor.update(() => {
      const [key] = keys;
      const node = lexical.$getNodeByKey(key);
      if (!threadMarkNode.$isThreadMarkNode(node))
        return;
      node.selectStart();
    });
  }
  _private.useLayoutEffect(() => {
    const el = divRef.current;
    if (el === null)
      return;
    onItemAdd(thread.id, el);
    return () => {
      onItemRemove(thread.id);
    };
  }, [thread.id, onItemAdd, onItemRemove]);
  return /* @__PURE__ */ jsxRuntime.jsx("div", {
    ref: divRef,
    className: classnames.classNames(
      "lb-lexical-anchored-threads-thread-container",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntime.jsx(Thread, {
      thread,
      "data-state": isActive ? "active" : "inactive",
      onClick: handleThreadClick,
      className: "lb-lexical-anchored-threads-thread",
      showComposer: isActive ? true : false
    })
  });
}
function useThreadToNodes() {
  const threadToNodes = react.useContext(commentPluginProvider.ThreadToNodesContext);
  if (threadToNodes === null) {
    throw new Error(
      "AnchoredThreads component must be used within a LiveblocksPlugin component."
    );
  }
  return threadToNodes;
}
function useActiveThreads() {
  const activeThreads = react.useContext(commentPluginProvider.ActiveThreadsContext);
  if (activeThreads === null) {
    throw new Error(
      "AnchoredThreads component must be used within LiveblocksPlugin."
    );
  }
  return activeThreads;
}

exports.AnchoredThreads = AnchoredThreads;
exports.compareNodes = compareNodes;
//# sourceMappingURL=anchored-threads.js.map
