'use strict';

var jsxRuntime = require('react/jsx-runtime');
var reactDom = require('@floating-ui/react-dom');
var LexicalCollaborationPlugin = require('@lexical/react/LexicalCollaborationPlugin');
var LexicalComposerContext = require('@lexical/react/LexicalComposerContext');
var core = require('@liveblocks/core');
var react$1 = require('@liveblocks/react');
var _private = require('@liveblocks/react/_private');
var yjs$1 = require('@liveblocks/yjs');
var react = require('react');
var yjs = require('yjs');
var commentPluginProvider = require('./comments/comment-plugin-provider.js');
var threadMarkNode = require('./comments/thread-mark-node.js');
var mentionNode = require('./mentions/mention-node.js');
var mentionPlugin = require('./mentions/mention-plugin.js');
var useRootElement = require('./use-root-element.js');

const providersMap = /* @__PURE__ */ new Map();
function useEditorStatus() {
  const provider = _private.useYjsProvider();
  const subscribe = react.useCallback(
    (onStoreChange) => {
      if (provider === void 0)
        return () => {
        };
      provider.on("status", onStoreChange);
      return () => {
        provider.off("status", onStoreChange);
      };
    },
    [provider]
  );
  const getSnapshot = react.useCallback(() => {
    if (provider === void 0) {
      return "not-loaded";
    }
    return provider.getStatus();
  }, [provider]);
  return react.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
function useIsEditorReady() {
  const yjsProvider = _private.useYjsProvider();
  const getSnapshot = react.useCallback(() => {
    const status = yjsProvider?.getStatus();
    return status === "synchronizing" || status === "synchronized";
  }, [yjsProvider]);
  const subscribe = react.useCallback(
    (callback) => {
      if (yjsProvider === void 0)
        return () => {
        };
      yjsProvider.on("status", callback);
      return () => {
        yjsProvider.off("status", callback);
      };
    },
    [yjsProvider]
  );
  return react.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
const LiveblocksPlugin = ({
  children
}) => {
  const isResolveMentionSuggestionsDefined = _private.useResolveMentionSuggestions() !== void 0;
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const room = react$1.useRoom();
  const previousRoomIdRef = react.useRef(null);
  if (!editor.hasNodes([threadMarkNode.ThreadMarkNode, mentionNode.MentionNode])) {
    throw new Error(
      "LiveblocksPlugin requires Lexical configuration to be wrapped in the `liveblocksConfig(options)` function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-react-lexical#liveblocksConfig"
    );
  }
  const [containerRef, setContainerRef] = react.useState(void 0);
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = reactDom.useFloating({
    strategy: "fixed",
    placement: "bottom",
    whileElementsMounted: (...args) => {
      return reactDom.autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  react.useEffect(() => {
    if (process.env.NODE_ENV !== "production") {
      if (!editor.getEditorState().isEmpty()) {
        console.warn(
          "Warning: LiveblocksPlugin: editorState in initialConfig detected, but must be null."
        );
      }
    }
  }, []);
  _private.useReportTextEditor(core.TextEditorType.Lexical, "root");
  const self = react$1.useSelf();
  const providerFactory = react.useCallback(
    (id, yjsDocMap) => {
      if (previousRoomIdRef.current !== null && previousRoomIdRef.current !== id) {
        const previousProvider = providersMap.get(id);
        if (previousProvider !== void 0) {
          previousProvider.destroy();
        }
      }
      let doc = yjsDocMap.get(id);
      if (doc === void 0) {
        doc = new yjs.Doc();
        const provider = new yjs$1.LiveblocksYjsProvider(room, doc);
        yjsDocMap.set(id, doc);
        providersMap.set(id, provider);
      }
      return core.nn(
        providersMap.get(id),
        "Internal error. Should never happen"
      );
    },
    [room]
  );
  const root = useRootElement.useRootElement();
  _private.useLayoutEffect(() => {
    if (root === null)
      return;
    setReference({
      getBoundingClientRect: () => root.getBoundingClientRect()
    });
  }, [setReference, root]);
  const handleFloatingRef = react.useCallback(
    (node) => {
      setFloating(node);
      setContainerRef({ current: node });
    },
    [setFloating, setContainerRef]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [
      /* @__PURE__ */ jsxRuntime.jsx("div", {
        ref: handleFloatingRef,
        style: {
          position: strategy,
          top: 0,
          left: 0,
          transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
          minWidth: "max-content"
        }
      }),
      self && /* @__PURE__ */ jsxRuntime.jsx(LexicalCollaborationPlugin.CollaborationPlugin, {
        id: room.id,
        providerFactory,
        username: self.info?.name ?? "",
        cursorColor: self.info?.color,
        cursorsContainerRef: containerRef,
        shouldBootstrap: true
      }, room.id),
      isResolveMentionSuggestionsDefined && /* @__PURE__ */ jsxRuntime.jsx(mentionPlugin.MentionPlugin, {}),
      /* @__PURE__ */ jsxRuntime.jsx(commentPluginProvider.CommentPluginProvider, {
        children
      })
    ]
  });
};

exports.LiveblocksPlugin = LiveblocksPlugin;
exports.useEditorStatus = useEditorStatus;
exports.useIsEditorReady = useIsEditorReady;
//# sourceMappingURL=liveblocks-plugin-provider.js.map
