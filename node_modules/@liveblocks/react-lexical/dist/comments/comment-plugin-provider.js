'use strict';

var jsxRuntime = require('react/jsx-runtime');
var LexicalComposerContext = require('@lexical/react/LexicalComposerContext');
var utils = require('@lexical/utils');
var client = require('@liveblocks/client');
var react$1 = require('@liveblocks/react');
var _private = require('@liveblocks/react/_private');
var lexical = require('lexical');
var react = require('react');
var getThreadMarkIds = require('./get-thread-mark-ids.js');
var threadMarkNode = require('./thread-mark-node.js');
var unwrapThreadMarkNode = require('./unwrap-thread-mark-node.js');

const OnDeleteThreadCallback = react.createContext(null);
const ActiveThreadsContext = react.createContext(null);
const IsActiveThreadContext = react.createContext(null);
const ThreadToNodesContext = react.createContext(
  null
);
function CommentPluginProvider({ children }) {
  const [editor, context] = LexicalComposerContext.useLexicalComposerContext();
  const [threadToNodes, setThreadToNodes] = react.useState(
    /* @__PURE__ */ new Map()
  );
  const [activeThreads, setActiveThreads] = react.useState([]);
  const client$1 = react$1.useClient();
  const room = react$1.useRoom();
  const isThreadActive = react.useCallback(
    (threadId) => {
      return activeThreads.includes(threadId);
    },
    [activeThreads]
  );
  const handleThreadDelete = react.useCallback(
    (threadId) => {
      editor.update(() => {
        const keys = threadToNodes.get(threadId);
        if (keys === void 0)
          return;
        for (const key of keys) {
          const node = lexical.$getNodeByKey(key);
          if (!threadMarkNode.$isThreadMarkNode(node))
            continue;
          node.deleteID(threadId);
          if (node.getIDs().length === 0) {
            unwrapThreadMarkNode(node);
          }
        }
      });
    },
    [editor, threadToNodes]
  );
  react$1.useErrorListener((err) => {
    if (err.context.type === "CREATE_THREAD_ERROR" && err.context.roomId === room.id) {
      handleThreadDelete(err.context.threadId);
    }
  });
  const store = _private.getUmbrellaStoreForClient(client$1);
  const roomId = room.id;
  const threadIds = _private.useSignal(
    store.outputs.threads,
    react.useCallback(
      (state) => state.findMany(roomId, { resolved: false }, "asc").map((thread) => thread.id),
      [roomId]
    ),
    client.shallow
  );
  react.useEffect(() => {
    function getThreadMarkElements() {
      const activeElements = /* @__PURE__ */ new Set();
      for (const id of threadIds) {
        const keys = threadToNodes.get(id);
        if (keys === void 0)
          continue;
        for (const key of keys) {
          const element = editor.getElementByKey(key);
          if (element === null)
            continue;
          activeElements.add(element);
        }
      }
      return activeElements;
    }
    const elements = getThreadMarkElements();
    const theme = context.getTheme();
    const classNames = ["lb-root", "lb-lexical-thread-mark"];
    if (theme && theme.liveblocks && "threadMark" in theme.liveblocks) {
      classNames.push(theme.liveblocks.threadMark);
    }
    elements.forEach((element) => {
      utils.addClassNamesToElement(element, ...classNames);
    });
    return () => {
      elements.forEach((element) => {
        utils.removeClassNamesFromElement(element, ...classNames);
      });
    };
  }, [context, editor, threadToNodes, threadIds]);
  react.useEffect(() => {
    function onMutation(mutations) {
      const state = editor.getEditorState();
      setThreadToNodes((prev) => {
        const updatedMap = new Map(prev);
        state.read(() => {
          for (const [key, mutation] of mutations) {
            if (mutation === "destroyed") {
              for (const [, nodes] of updatedMap) {
                nodes.delete(key);
              }
            } else if (mutation === "created" || mutation === "updated") {
              const node = lexical.$getNodeByKey(key);
              if (!threadMarkNode.$isThreadMarkNode(node))
                continue;
              const threadIds2 = node.getIDs();
              for (const id of threadIds2) {
                const keys = updatedMap.get(id) ?? /* @__PURE__ */ new Set();
                keys.add(key);
                updatedMap.set(id, keys);
              }
            }
          }
        });
        return updatedMap;
      });
    }
    return editor.registerMutationListener(threadMarkNode.ThreadMarkNode, onMutation);
  }, [editor]);
  react.useEffect(() => {
    function $getThreadIds(selection) {
      if (selection === null)
        return [];
      if (!lexical.$isRangeSelection(selection))
        return [];
      const anchor = selection.anchor.getNode();
      if (!lexical.$isTextNode(anchor))
        return [];
      return getThreadMarkIds(anchor, selection.anchor.offset) ?? [];
    }
    function $onStateRead() {
      const selection = lexical.$getSelection();
      const threadIds2 = $getThreadIds(selection).filter((id) => {
        return store.outputs.threads.get().findMany(roomId, { resolved: false }, "asc").some((thread) => thread.id === id);
      });
      setActiveThreads(threadIds2);
    }
    const unsubscribeCache = store.outputs.threads.subscribe(() => {
      editor.getEditorState().read($onStateRead);
    });
    const unregisterUpdateListener = editor.registerUpdateListener(
      ({ editorState: state }) => {
        state.read($onStateRead);
      }
    );
    return () => {
      unregisterUpdateListener();
      unsubscribeCache();
    };
  }, [editor, client$1, roomId, store]);
  react.useEffect(() => {
    function getActiveElements() {
      const activeElements2 = /* @__PURE__ */ new Set();
      for (const thread of activeThreads) {
        const keys = threadToNodes.get(thread);
        if (keys === void 0)
          continue;
        for (const key of keys) {
          const element = editor.getElementByKey(key);
          if (element === null)
            continue;
          activeElements2.add(element);
        }
      }
      return activeElements2;
    }
    const activeElements = getActiveElements();
    activeElements.forEach((element) => {
      element.setAttribute("data-state", "active");
    });
    return () => {
      activeElements.forEach((element) => {
        element.removeAttribute("data-state");
      });
    };
  }, [activeThreads, editor, threadToNodes]);
  react.useEffect(() => {
    return utils.registerNestedElementResolver(
      editor,
      threadMarkNode.ThreadMarkNode,
      (from) => {
        return threadMarkNode.$createThreadMarkNode(from.getIDs());
      },
      (from, to) => {
        const ids = from.getIDs();
        ids.forEach((id) => {
          to.addID(id);
        });
      }
    );
  }, [editor]);
  return /* @__PURE__ */ jsxRuntime.jsx(OnDeleteThreadCallback.Provider, {
    value: handleThreadDelete,
    children: /* @__PURE__ */ jsxRuntime.jsx(ActiveThreadsContext.Provider, {
      value: activeThreads,
      children: /* @__PURE__ */ jsxRuntime.jsx(IsActiveThreadContext.Provider, {
        value: isThreadActive,
        children: /* @__PURE__ */ jsxRuntime.jsx(ThreadToNodesContext.Provider, {
          value: threadToNodes,
          children
        })
      })
    })
  });
}
function useIsThreadActive(threadId) {
  const isActive = react.useContext(IsActiveThreadContext);
  if (isActive === null) {
    throw new Error(
      "useIsThreadActive must be used within LiveblocksPlugin. For more information: https://liveblocks.io/docs/api-reference/liveblocks-react-lexical#useIsThreadActive"
    );
  }
  return isActive(threadId);
}

exports.ActiveThreadsContext = ActiveThreadsContext;
exports.CommentPluginProvider = CommentPluginProvider;
exports.IsActiveThreadContext = IsActiveThreadContext;
exports.OnDeleteThreadCallback = OnDeleteThreadCallback;
exports.ThreadToNodesContext = ThreadToNodesContext;
exports.useIsThreadActive = useIsThreadActive;
//# sourceMappingURL=comment-plugin-provider.js.map
