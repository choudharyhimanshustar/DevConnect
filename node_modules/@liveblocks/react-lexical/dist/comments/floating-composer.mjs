import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { useFloating, offset, autoUpdate, inline, flip, hide, shift, limitShift, size } from '@floating-ui/react-dom';
import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';
import { useCreateThread } from '@liveblocks/react';
import { useLayoutEffect } from '@liveblocks/react/_private';
import { Composer } from '@liveblocks/react-ui';
import { createCommand, $getSelection, $isRangeSelection, COMMAND_PRIORITY_EDITOR, $setSelection } from 'lexical';
import { forwardRef, useState, useEffect, useCallback } from 'react';
import { createPortal } from 'react-dom';
import { createDOMRange } from '../create-dom-range.mjs';
import { createRectsFromDOMRange } from '../create-rects-from-dom-range.mjs';
import $wrapSelectionInThreadMarkNode from './wrap-selection-in-thread-mark-node.mjs';

const OPEN_FLOATING_COMPOSER_COMMAND = createCommand("OPEN_FLOATING_COMPOSER_COMMAND");
const FloatingComposer = forwardRef(function FloatingComposer2(props, forwardedRef) {
  const [range, setRange] = useState(null);
  const [editor] = useLexicalComposerContext();
  useEffect(() => {
    return editor.registerCommand(
      OPEN_FLOATING_COMPOSER_COMMAND,
      () => {
        const selection = $getSelection();
        if (!$isRangeSelection(selection))
          return false;
        if (selection.isCollapsed())
          return false;
        const { anchor, focus } = selection;
        const range2 = createDOMRange(
          editor,
          anchor.getNode(),
          anchor.offset,
          focus.getNode(),
          focus.offset
        );
        setRange(range2);
        return true;
      },
      COMMAND_PRIORITY_EDITOR
    );
  }, [editor]);
  if (range === null)
    return null;
  return /* @__PURE__ */ jsx(FloatingComposerImpl, {
    ref: forwardedRef,
    ...props,
    range,
    onRangeChange: setRange
  });
});
const FloatingComposerImpl = forwardRef(function FloatingComposer3(props, forwardedRef) {
  const {
    range,
    onRangeChange,
    onKeyDown,
    onComposerSubmit,
    ...composerProps
  } = props;
  const [editor] = useLexicalComposerContext();
  const createThread = useCreateThread();
  const $onStateRead = useCallback(() => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection) || selection.isCollapsed()) {
      return null;
    }
    const { anchor, focus } = selection;
    const range2 = createDOMRange(
      editor,
      anchor.getNode(),
      anchor.offset,
      focus.getNode(),
      focus.offset
    );
    return range2;
  }, [editor]);
  useEffect(() => {
    return editor.registerUpdateListener(({ editorState: state, tags }) => {
      if (!tags.has("collaboration")) {
        onRangeChange(null);
        return;
      }
      const range2 = state.read(() => $onStateRead());
      onRangeChange(range2);
    });
  }, [editor, range, onRangeChange, $onStateRead]);
  const onThreadCreate = useCallback(
    (threadId) => {
      editor.update(() => {
        const selection = $getSelection();
        if (!$isRangeSelection(selection))
          return;
        if (selection.isCollapsed())
          return;
        const isBackward = selection.isBackward();
        $wrapSelectionInThreadMarkNode(selection, isBackward, threadId);
        $setSelection(null);
      });
    },
    [editor]
  );
  const handleComposerSubmit = useCallback(
    (comment, event) => {
      onComposerSubmit?.(comment, event);
      if (event.defaultPrevented)
        return;
      event.preventDefault();
      const thread = createThread({
        body: comment.body,
        attachments: comment.attachments,
        metadata: props.metadata ?? {}
      });
      onThreadCreate(thread.id);
    },
    [onThreadCreate, onComposerSubmit, props.metadata, createThread]
  );
  function handleKeyDown(event) {
    onKeyDown?.(event);
    if (event.isDefaultPrevented())
      return;
    if (event.key === "Escape") {
      onRangeChange(null);
      editor.focus();
    }
  }
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [
      /* @__PURE__ */ jsx(ActiveSelectionPortal, {
        range,
        container: document.body
      }),
      /* @__PURE__ */ jsx(FloatingComposerPortal, {
        range,
        container: document.body,
        children: /* @__PURE__ */ jsx(Composer, {
          autoFocus: true,
          ...composerProps,
          onKeyDown: handleKeyDown,
          onComposerSubmit: handleComposerSubmit,
          ref: forwardedRef
        })
      })
    ]
  });
});
function ActiveSelectionPortal({
  range,
  container
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = useFloating({
    strategy: "fixed",
    placement: "bottom",
    middleware: [offset(-range.getBoundingClientRect().height)],
    whileElementsMounted: (...args) => {
      return autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  useLayoutEffect(() => {
    setReference(range);
  }, [setReference, range]);
  const [editor] = useLexicalComposerContext();
  const rects = createRectsFromDOMRange(editor, range);
  return createPortal(
    /* @__PURE__ */ jsx(Fragment, {
      children: /* @__PURE__ */ jsx("span", {
        ref: setFloating,
        style: {
          position: strategy,
          top: 0,
          left: 0,
          transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
          minWidth: "max-content",
          width: range.getBoundingClientRect().width,
          height: range.getBoundingClientRect().height,
          pointerEvents: "none"
        },
        className: "lb-root lb-portal",
        children: rects.map((rect) => /* @__PURE__ */ jsx("span", {
          style: {
            position: "absolute",
            top: rect.top - range.getBoundingClientRect().top,
            left: rect.left - range.getBoundingClientRect().left,
            width: rect.width,
            height: rect.height,
            backgroundColor: "var(--lb-selection, rgba(0, 0, 255, 0.2))",
            pointerEvents: "none"
          },
          className: "lb-selection lb-lexical-active-selection"
        }, JSON.stringify(rect)))
      })
    }),
    container
  );
}
const FLOATING_COMPOSER_COLLISION_PADDING = 10;
function FloatingComposerPortal({
  container,
  range,
  children
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = useFloating({
    strategy: "fixed",
    placement: "bottom",
    middleware: [
      inline({ padding: FLOATING_COMPOSER_COLLISION_PADDING }),
      flip({ padding: FLOATING_COMPOSER_COLLISION_PADDING, crossAxis: false }),
      offset(10),
      hide({ padding: FLOATING_COMPOSER_COLLISION_PADDING }),
      shift({
        padding: FLOATING_COMPOSER_COLLISION_PADDING,
        limiter: limitShift()
      }),
      size({ padding: FLOATING_COMPOSER_COLLISION_PADDING })
    ],
    whileElementsMounted: (...args) => {
      return autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  useLayoutEffect(() => {
    setReference(range);
  }, [range, setReference]);
  return createPortal(
    /* @__PURE__ */ jsx("div", {
      ref: setFloating,
      style: {
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content"
      },
      className: "lb-root lb-portal lb-elevation lb-lexical-floating lb-lexical-floating-composer",
      children
    }),
    container
  );
}

export { FLOATING_COMPOSER_COLLISION_PADDING, FloatingComposer, OPEN_FLOATING_COMPOSER_COMMAND };
//# sourceMappingURL=floating-composer.mjs.map
