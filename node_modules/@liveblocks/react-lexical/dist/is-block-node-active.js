'use strict';

var utils = require('@lexical/utils');
var lexical = require('lexical');

function isParentRootOrShadowRoot(node) {
  const parent = node.getParent();
  return parent !== null && lexical.$isRootOrShadowRoot(parent);
}
const activeNodesByEditor = /* @__PURE__ */ new WeakMap();
function getActiveBlockNodes(editor) {
  const currentState = editor.getEditorState();
  return currentState.read(() => {
    const selection = lexical.$getSelection();
    if (!lexical.$isRangeSelection(selection)) {
      activeNodesByEditor.delete(editor);
      return [];
    }
    const cache = activeNodesByEditor.get(editor);
    if (cache?.state === currentState) {
      return cache.nodes;
    }
    const anchor = selection.anchor.getNode();
    const focus = selection.focus.getNode();
    const commonAncestor = anchor.getCommonAncestor(focus);
    let activeNodes = [];
    if (commonAncestor && !lexical.$isRootOrShadowRoot(commonAncestor)) {
      const activeNode = isParentRootOrShadowRoot(commonAncestor) ? commonAncestor : utils.$findMatchingParent(commonAncestor, isParentRootOrShadowRoot);
      if (activeNode) {
        activeNodes = [activeNode];
      }
    } else {
      activeNodes = selection.getNodes().filter((node) => lexical.$isRootOrShadowRoot(node.getParent()));
    }
    activeNodesByEditor.set(editor, {
      state: currentState,
      nodes: activeNodes
    });
    return activeNodes;
  });
}
function isBlockNodeActive(editor, isActive) {
  const activeNodes = getActiveBlockNodes(editor);
  if (activeNodes.length === 0) {
    return false;
  }
  return activeNodes.every(isActive);
}

exports.isBlockNodeActive = isBlockNodeActive;
//# sourceMappingURL=is-block-node-active.js.map
