// src/contexts.ts
import { createContext, useContext } from "react";
var RoomContext = createContext(null);
function useRoomOrNull() {
  return useContext(RoomContext);
}
function useIsInsideRoom() {
  const room = useRoomOrNull();
  return room !== null;
}

// src/use-sync-external-store-with-selector.ts
import {
  useDebugValue,
  useEffect,
  useMemo,
  useRef,
  useSyncExternalStore
} from "react";
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
}
function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
  const instRef = useRef(null);
  let inst;
  if (instRef.current === null) {
    inst = {
      hasValue: false,
      value: null
    };
    instRef.current = inst;
  } else {
    inst = instRef.current;
  }
  const [getSelection, getServerSelection] = useMemo(() => {
    let hasMemo = false;
    let memoizedSnapshot;
    let memoizedSelection;
    const memoizedSelector = (nextSnapshot) => {
      if (!hasMemo) {
        hasMemo = true;
        memoizedSnapshot = nextSnapshot;
        const nextSelection2 = selector(nextSnapshot);
        if (isEqual !== void 0) {
          if (inst.hasValue) {
            const currentSelection = inst.value;
            if (isEqual(currentSelection, nextSelection2)) {
              memoizedSelection = currentSelection;
              return currentSelection;
            }
          }
        }
        memoizedSelection = nextSelection2;
        return nextSelection2;
      }
      const prevSnapshot = memoizedSnapshot;
      const prevSelection = memoizedSelection;
      if (is(prevSnapshot, nextSnapshot)) {
        return prevSelection;
      }
      const nextSelection = selector(nextSnapshot);
      if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
        memoizedSnapshot = nextSnapshot;
        return prevSelection;
      }
      memoizedSnapshot = nextSnapshot;
      memoizedSelection = nextSelection;
      return nextSelection;
    };
    const maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
    const getSnapshotWithSelector = () => memoizedSelector(getSnapshot());
    const getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : () => memoizedSelector(maybeGetServerSnapshot());
    return [getSnapshotWithSelector, getServerSnapshotWithSelector];
  }, [getSnapshot, getServerSnapshot, selector, isEqual]);
  const value = useSyncExternalStore(
    subscribe,
    getSelection,
    getServerSelection
  );
  useEffect(() => {
    inst.hasValue = true;
    inst.value = value;
  }, [value]);
  useDebugValue(value);
  return value;
}

// src/use-signal.ts
var identity = (value) => value;
function useSignal(signal, selector, isEqual) {
  return useSyncExternalStoreWithSelector(
    signal.subscribe,
    signal.get,
    signal.get,
    selector ?? identity,
    isEqual
  );
}

// src/liveblocks.tsx
import {
  assert,
  createClient,
  kInternal as kInternal2,
  makePoller,
  raise,
  shallow as shallow4
} from "@liveblocks/core";
import {
  createContext as createContext2,
  useCallback as useCallback2,
  useContext as useContext2,
  useEffect as useEffect3,
  useMemo as useMemo2,
  useState,
  useSyncExternalStore as useSyncExternalStore2
} from "react";

// src/config.ts
var SECONDS = 1e3;
var MINUTES = 60 * SECONDS;
var config = {
  SMOOTH_DELAY: 1 * SECONDS,
  NOTIFICATIONS_POLL_INTERVAL: 1 * MINUTES,
  NOTIFICATIONS_MAX_STALE_TIME: 5 * SECONDS,
  ROOM_THREADS_POLL_INTERVAL: 5 * MINUTES,
  ROOM_THREADS_MAX_STALE_TIME: 5 * SECONDS,
  USER_THREADS_POLL_INTERVAL: 1 * MINUTES,
  USER_THREADS_MAX_STALE_TIME: 5 * SECONDS,
  HISTORY_VERSIONS_POLL_INTERVAL: 1 * MINUTES,
  HISTORY_VERSIONS_MAX_STALE_TIME: 5 * SECONDS,
  NOTIFICATION_SETTINGS_POLL_INTERVAL: 1 * MINUTES,
  NOTIFICATION_SETTINGS_MAX_STALE_TIME: 5 * SECONDS
};

// src/lib/AsyncResult.ts
var ASYNC_LOADING = Object.freeze({ isLoading: true });
var ASYNC_ERR = (error) => Object.freeze({ isLoading: false, error });
function ASYNC_OK(fieldOrData, data) {
  if (arguments.length === 1) {
    return Object.freeze({ isLoading: false, data: fieldOrData });
  } else {
    return Object.freeze({ isLoading: false, [fieldOrData]: data });
  }
}

// src/lib/itertools.ts
function find(it, predicate) {
  for (const item of it) {
    if (predicate(item)) return item;
  }
  return void 0;
}
function count(it, predicate) {
  let total = 0;
  for (const item of it) {
    if (predicate(item)) total++;
  }
  return total;
}

// src/lib/ssr.ts
function ensureNotServerSide() {
  if (typeof window === "undefined") {
    throw new Error(
      "You cannot use the Suspense version of Liveblocks hooks server side. Make sure to only call them client side by using a ClientSideSuspense wrapper.\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#ClientSideSuspense"
    );
  }
}

// src/lib/use-initial.ts
import { useCallback, useReducer } from "react";

// src/lib/use-latest.ts
import { useEffect as useEffect2, useRef as useRef2 } from "react";
function useLatest(value) {
  const ref = useRef2(value);
  useEffect2(() => {
    ref.current = value;
  }, [value]);
  return ref;
}

// src/lib/use-initial.ts
var noop = (state) => state;
function useInitial(value) {
  return useReducer(noop, value)[0];
}
function useInitialUnlessFunction(latestValue) {
  const frozenValue = useInitial(latestValue);
  if (typeof frozenValue === "function") {
    const ref = useLatest(latestValue);
    return useCallback((...args) => ref.current(...args), [
      ref
    ]);
  } else {
    return frozenValue;
  }
}

// src/lib/use-polyfill.ts
var use = (
  // React.use ||
  (promise) => {
    if (promise.status === "pending") {
      throw promise;
    } else if (promise.status === "fulfilled") {
      return promise.value;
    } else if (promise.status === "rejected") {
      throw promise.reason;
    } else {
      promise.status = "pending";
      promise.then(
        (v) => {
          promise.status = "fulfilled";
          promise.value = v;
        },
        (e) => {
          promise.status = "rejected";
          promise.reason = e;
        }
      );
      throw promise;
    }
  }
);

// src/umbrella-store.ts
import {
  autoRetry,
  batch as batch2,
  compactObject,
  console as console2,
  DefaultMap,
  DerivedSignal,
  kInternal,
  MutableSignal as MutableSignal2,
  nanoid,
  nn,
  shallow as shallow3,
  Signal,
  stringify
} from "@liveblocks/core";

// src/lib/autobind.ts
function autobind(self) {
  const seen = /* @__PURE__ */ new Set();
  seen.add("constructor");
  let obj = self.constructor.prototype;
  do {
    for (const key of Reflect.ownKeys(obj)) {
      if (seen.has(key)) continue;
      const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);
      if (typeof descriptor?.value === "function") {
        seen.add(key);
        self[key] = self[key].bind(self);
      }
    }
  } while ((obj = Reflect.getPrototypeOf(obj)) && obj !== Object.prototype);
}

// src/lib/shallow2.ts
import { isPlainObject, shallow } from "@liveblocks/core";
function shallow2(a, b) {
  if (!isPlainObject(a) || !isPlainObject(b)) {
    return shallow(a, b);
  }
  const keysA = Object.keys(a);
  if (keysA.length !== Object.keys(b).length) {
    return false;
  }
  return keysA.every(
    (key) => Object.prototype.hasOwnProperty.call(b, key) && shallow(a[key], b[key])
  );
}

// src/ThreadDB.ts
import { batch, MutableSignal, SortedList } from "@liveblocks/core";

// src/lib/querying.ts
import { isStartsWithOperator } from "@liveblocks/core";
function makeThreadsFilter(query) {
  return (thread) => matchesQuery(thread, query) && matchesMetadata(thread, query);
}
function matchesQuery(thread, q) {
  return q.resolved === void 0 || thread.resolved === q.resolved;
}
function matchesMetadata(thread, q) {
  const metadata = thread.metadata;
  return q.metadata === void 0 || Object.entries(q.metadata).every(
    ([key, op]) => (
      // Ignore explicit-undefined filters
      // Boolean logic: op? => value matches the operator
      op === void 0 || matchesOperator(metadata[key], op)
    )
  );
}
function matchesOperator(value, op) {
  if (op === null) {
    return value === void 0;
  } else if (isStartsWithOperator(op)) {
    return typeof value === "string" && value.startsWith(op.startsWith);
  } else {
    return value === op;
  }
}

// src/ThreadDB.ts
function sanitizeThread(thread) {
  if (thread.deletedAt) {
    if (thread.comments.length > 0) {
      return { ...thread, comments: [] };
    }
  }
  const hasComment = thread.comments.some((c) => !c.deletedAt);
  if (!hasComment) {
    return { ...thread, deletedAt: /* @__PURE__ */ new Date(), comments: [] };
  }
  return thread;
}
var ThreadDB = class _ThreadDB {
  #byId;
  #asc;
  #desc;
  // This signal will be notified on every mutation
  signal;
  constructor() {
    this.#asc = SortedList.from([], (t1, t2) => {
      const d1 = t1.createdAt;
      const d2 = t2.createdAt;
      return d1 < d2 ? true : d1 === d2 ? t1.id < t2.id : false;
    });
    this.#desc = SortedList.from([], (t1, t2) => {
      const d2 = t2.updatedAt;
      const d1 = t1.updatedAt;
      return d2 < d1 ? true : d2 === d1 ? t2.id < t1.id : false;
    });
    this.#byId = /* @__PURE__ */ new Map();
    this.signal = new MutableSignal(this);
  }
  //
  // Public APIs
  //
  clone() {
    const newPool = new _ThreadDB();
    newPool.#byId = new Map(this.#byId);
    newPool.#asc = this.#asc.clone();
    newPool.#desc = this.#desc.clone();
    return newPool;
  }
  /** Returns an existing thread by ID. Will never return a deleted thread. */
  get(threadId) {
    const thread = this.getEvenIfDeleted(threadId);
    return thread?.deletedAt ? void 0 : thread;
  }
  /** Returns the (possibly deleted) thread by ID. */
  getEvenIfDeleted(threadId) {
    return this.#byId.get(threadId);
  }
  /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */
  upsert(thread) {
    this.signal.mutate(() => {
      thread = sanitizeThread(thread);
      const id = thread.id;
      const toRemove = this.#byId.get(id);
      if (toRemove) {
        if (toRemove.deletedAt) return false;
        this.#asc.remove(toRemove);
        this.#desc.remove(toRemove);
      }
      if (!thread.deletedAt) {
        this.#asc.add(thread);
        this.#desc.add(thread);
      }
      this.#byId.set(id, thread);
      return true;
    });
  }
  /** Like .upsert(), except it won't update if a thread by this ID already exists. */
  // TODO Consider renaming this to just .upsert(). I'm not sure if we really
  // TODO need the raw .upsert(). Would be nice if this behavior was the default.
  upsertIfNewer(thread) {
    const existing = this.get(thread.id);
    if (!existing || thread.updatedAt >= existing.updatedAt) {
      this.upsert(thread);
    }
  }
  applyDelta(newThreads, deletedThreads) {
    batch(() => {
      for (const thread of newThreads) {
        this.upsertIfNewer(thread);
      }
      for (const { id, deletedAt } of deletedThreads) {
        const existing = this.getEvenIfDeleted(id);
        if (!existing) continue;
        this.delete(id, deletedAt);
      }
    });
  }
  /**
   * Marks a thread as deleted. It will no longer pop up in .findMany()
   * queries, but it can still be accessed via `.getEvenIfDeleted()`.
   */
  delete(threadId, deletedAt) {
    const existing = this.#byId.get(threadId);
    if (existing && !existing.deletedAt) {
      this.upsert({ ...existing, deletedAt, updatedAt: deletedAt });
    }
  }
  /**
   * Returns all threads matching a given roomId and query. If roomId is not
   * specified, it will return all threads matching the query, across all
   * rooms.
   *
   * Returns the results in the requested order. Please note:
   *   'asc'  means by createdAt ASC
   *   'desc' means by updatedAt DESC
   *
   * Will never return deleted threads in the result.
   */
  findMany(roomId, query, direction) {
    const index = direction === "desc" ? this.#desc : this.#asc;
    const crit = [];
    if (roomId !== void 0) {
      crit.push((t) => t.roomId === roomId);
    }
    crit.push(makeThreadsFilter(query));
    return Array.from(index.filter((t) => crit.every((pred) => pred(t))));
  }
};

// src/umbrella-store.ts
function makeRoomThreadsQueryKey(roomId, query) {
  return stringify([roomId, query ?? {}]);
}
function makeUserThreadsQueryKey(query) {
  return stringify(query ?? {});
}
function usify(promise) {
  if ("status" in promise) {
    return promise;
  }
  const usable = promise;
  usable.status = "pending";
  usable.then(
    (value) => {
      usable.status = "fulfilled";
      usable.value = value;
    },
    (err) => {
      usable.status = "rejected";
      usable.reason = err;
    }
  );
  return usable;
}
var noop2 = Promise.resolve();
var PaginatedResource = class {
  #signal;
  signal;
  #fetchPage;
  #pendingFetchMore;
  constructor(fetchPage) {
    this.#signal = new Signal(ASYNC_LOADING);
    this.#fetchPage = fetchPage;
    this.#pendingFetchMore = null;
    this.signal = this.#signal.asReadonly();
    autobind(this);
  }
  get() {
    return this.#signal.get();
  }
  #patch(patch) {
    const state = this.#signal.get();
    if (state.data === void 0) return;
    this.#signal.set(ASYNC_OK({ ...state.data, ...patch }));
  }
  async #fetchMore() {
    const state = this.#signal.get();
    if (!state.data?.cursor || state.data.isFetchingMore) {
      return;
    }
    this.#patch({ isFetchingMore: true });
    try {
      const nextCursor = await this.#fetchPage(state.data.cursor);
      this.#patch({
        cursor: nextCursor,
        hasFetchedAll: nextCursor === null,
        fetchMoreError: void 0,
        isFetchingMore: false
      });
    } catch (err) {
      this.#patch({
        isFetchingMore: false,
        fetchMoreError: err
      });
    }
  }
  fetchMore() {
    const state = this.#signal.get();
    if (!state.data?.cursor) return noop2;
    if (!this.#pendingFetchMore) {
      this.#pendingFetchMore = this.#fetchMore().finally(() => {
        this.#pendingFetchMore = null;
      });
    }
    return this.#pendingFetchMore;
  }
  #cachedPromise = null;
  waitUntilLoaded() {
    if (this.#cachedPromise) {
      return this.#cachedPromise;
    }
    const initialPageFetch$ = autoRetry(
      () => this.#fetchPage(
        /* cursor */
        void 0
      ),
      5,
      [5e3, 5e3, 1e4, 15e3]
    );
    const promise = usify(initialPageFetch$);
    promise.then(
      (cursor) => {
        this.#signal.set(
          ASYNC_OK({
            cursor,
            hasFetchedAll: cursor === null,
            isFetchingMore: false,
            fetchMoreError: void 0,
            fetchMore: this.fetchMore
          })
        );
      },
      (err) => {
        this.#signal.set(ASYNC_ERR(err));
        setTimeout(() => {
          this.#cachedPromise = null;
          this.#signal.set(ASYNC_LOADING);
        }, 5e3);
      }
    );
    this.#cachedPromise = promise;
    return this.#cachedPromise;
  }
};
var SinglePageResource = class {
  #signal;
  signal;
  #fetchPage;
  constructor(fetchPage) {
    this.#signal = new Signal(ASYNC_LOADING);
    this.signal = this.#signal.asReadonly();
    this.#fetchPage = fetchPage;
    autobind(this);
  }
  get() {
    return this.#signal.get();
  }
  #cachedPromise = null;
  waitUntilLoaded() {
    if (this.#cachedPromise) {
      return this.#cachedPromise;
    }
    const initialFetcher$ = autoRetry(
      () => this.#fetchPage(),
      5,
      [5e3, 5e3, 1e4, 15e3]
    );
    const promise = usify(initialFetcher$);
    promise.then(
      () => {
        this.#signal.set(ASYNC_OK(void 0));
      },
      (err) => {
        this.#signal.set(ASYNC_ERR(err));
        setTimeout(() => {
          this.#cachedPromise = null;
          this.#signal.set(ASYNC_LOADING);
        }, 5e3);
      }
    );
    this.#cachedPromise = promise;
    return promise;
  }
};
function createStore_forNotifications() {
  const signal = new MutableSignal2(/* @__PURE__ */ new Map());
  function markRead(notificationId, readAt) {
    signal.mutate((lut) => {
      const existing = lut.get(notificationId);
      if (!existing) {
        return false;
      }
      lut.set(notificationId, { ...existing, readAt });
      return true;
    });
  }
  function markAllRead(readAt) {
    signal.mutate((lut) => {
      for (const n of lut.values()) {
        n.readAt = readAt;
      }
    });
  }
  function deleteOne(inboxNotificationId) {
    signal.mutate((lut) => lut.delete(inboxNotificationId));
  }
  function clear() {
    signal.mutate((lut) => lut.clear());
  }
  function applyDelta(newNotifications, deletedNotifications) {
    signal.mutate((lut) => {
      let mutated = false;
      for (const n of newNotifications) {
        const existing = lut.get(n.id);
        if (existing) {
          const result = compareInboxNotifications(existing, n);
          if (result === 1) continue;
        }
        lut.set(n.id, n);
        mutated = true;
      }
      for (const n of deletedNotifications) {
        lut.delete(n.id);
        mutated = true;
      }
      return mutated;
    });
  }
  function updateAssociatedNotification(newComment) {
    signal.mutate((lut) => {
      const existing = find(
        lut.values(),
        (notification) => notification.kind === "thread" && notification.threadId === newComment.threadId
      );
      if (!existing) return false;
      lut.set(existing.id, {
        ...existing,
        notifiedAt: newComment.createdAt,
        readAt: newComment.createdAt
      });
      return true;
    });
  }
  function upsert(notification) {
    signal.mutate((lut) => {
      lut.set(notification.id, notification);
    });
  }
  return {
    signal: signal.asReadonly(),
    // Mutations
    markAllRead,
    markRead,
    delete: deleteOne,
    applyDelta,
    clear,
    updateAssociatedNotification,
    upsert
  };
}
function createStore_forRoomNotificationSettings(updates) {
  const baseSignal = new MutableSignal2(/* @__PURE__ */ new Map());
  function update(roomId, settings) {
    baseSignal.mutate((lut) => {
      lut.set(roomId, settings);
    });
  }
  return {
    signal: DerivedSignal.from(
      baseSignal,
      updates,
      (base, updates2) => applyOptimisticUpdates_forSettings(base, updates2)
    ),
    // Mutations
    update
  };
}
function createStore_forHistoryVersions() {
  const baseSignal = new MutableSignal2(
    new DefaultMap(() => /* @__PURE__ */ new Map())
  );
  function update(roomId, versions) {
    baseSignal.mutate((lut) => {
      const versionsById = lut.getOrCreate(roomId);
      for (const version of versions) {
        versionsById.set(version.id, version);
      }
    });
  }
  return {
    signal: DerivedSignal.from(
      baseSignal,
      (hv) => Object.fromEntries(
        [...hv].map(([roomId, versions]) => [
          roomId,
          Object.fromEntries(versions)
        ])
      )
    ),
    // Mutations
    update
  };
}
function createStore_forPermissionHints() {
  const signal = new MutableSignal2(
    new DefaultMap(() => /* @__PURE__ */ new Set())
  );
  function update(newHints) {
    signal.mutate((lut) => {
      for (const [roomId, newPermissions] of Object.entries(newHints)) {
        const existing = lut.getOrCreate(roomId);
        for (const permission of newPermissions) {
          existing.add(permission);
        }
      }
    });
  }
  return {
    signal: signal.asReadonly(),
    // Mutations
    update
  };
}
function createStore_forOptimistic(client) {
  const signal = new Signal([]);
  const syncSource = client[kInternal].createSyncSource();
  signal.subscribe(
    () => syncSource.setSyncStatus(
      signal.get().length > 0 ? "synchronizing" : "synchronized"
    )
  );
  function add(optimisticUpdate) {
    const id = nanoid();
    const newUpdate = { ...optimisticUpdate, id };
    signal.set((state) => [...state, newUpdate]);
    return id;
  }
  function remove(optimisticId) {
    signal.set((state) => state.filter((ou) => ou.id !== optimisticId));
  }
  return {
    signal: signal.asReadonly(),
    // Mutations
    add,
    remove
  };
}
var UmbrellaStore = class {
  #client;
  //
  // Internally, the UmbrellaStore keeps track of a few source signals that can
  // be set and mutated individually. When any of those are mutated then the
  // clean "external state" is recomputed.
  //
  //   Mutate inputs...                                             ...observe clean/consistent output!
  //
  //            .-> Base ThreadDB ---------+                 +----> Clean threads by ID       (Part 1)
  //           /                           |                 |
  //   mutate ----> Base Notifications --+ |                 | +--> Clean notifications       (Part 1)
  //          \                          | |                 | |    & notifications by ID
  //         | \                         | |      Apply      | |
  //         |   `-> OptimisticUpdates --+--+--> Optimistic --+-+--> Notification Settings    (Part 2)
  //          \                          |        Updates       |
  //           `------- etc etc ---------+                      +--> History Versions         (Part 3)
  //                       ^
  //                       |
  //                       |                        ^                  ^
  //                    Signal                      |                  |
  //                      or                   DerivedSignal      DerivedSignals
  //                  MutableSignal
  //
  //
  // Input signals.
  // (Can be mutated directly.)
  //
  // XXX_vincent Now that we have createStore_forX, we should probably also change
  // `threads` to this pattern, ie create a createStore_forThreads helper as
  // well. It almost works like that already anyway!
  threads;
  // Exposes its signal under `.signal` prop
  notifications;
  roomNotificationSettings;
  // prettier-ignore
  historyVersions;
  permissionHints;
  optimisticUpdates;
  //
  // Output signals.
  // (Readonly, clean, consistent. With optimistic updates applied.)
  //
  // Note that the output of threadifications signal is the same as the ones for
  // threads and notifications separately, but the threadifications signal will
  // be updated whenever either of them change.
  //
  outputs;
  // Notifications
  #notificationsLastRequestedAt = null;
  // Keeps track of when we successfully requested an inbox notifications update for the last time. Will be `null` as long as the first successful fetch hasn't happened yet.
  #notificationsPaginationState;
  // Room Threads
  #roomThreadsLastRequestedAtByRoom = /* @__PURE__ */ new Map();
  // User Threads
  #userThreadsLastRequestedAt = null;
  // Room versions
  #roomVersionsLastRequestedAtByRoom = /* @__PURE__ */ new Map();
  constructor(client) {
    this.#client = client[kInternal].as();
    this.optimisticUpdates = createStore_forOptimistic(this.#client);
    this.permissionHints = createStore_forPermissionHints();
    this.#notificationsPaginationState = new PaginatedResource(
      async (cursor) => {
        const result = await this.#client.getInboxNotifications({ cursor });
        this.updateThreadifications(result.threads, result.inboxNotifications);
        if (this.#notificationsLastRequestedAt === null) {
          this.#notificationsLastRequestedAt = result.requestedAt;
        }
        const nextCursor = result.nextCursor;
        return nextCursor;
      }
    );
    this.threads = new ThreadDB();
    this.notifications = createStore_forNotifications();
    this.roomNotificationSettings = createStore_forRoomNotificationSettings(
      this.optimisticUpdates.signal
    );
    this.historyVersions = createStore_forHistoryVersions();
    const threadifications = DerivedSignal.from(
      this.threads.signal,
      this.notifications.signal,
      this.optimisticUpdates.signal,
      (ts, ns, updates) => applyOptimisticUpdates_forThreadifications(ts, ns, updates)
    );
    const threads = DerivedSignal.from(threadifications, (s) => s.threadsDB);
    const notifications = DerivedSignal.from(
      threadifications,
      (s) => ({
        sortedNotifications: s.sortedNotifications,
        notificationsById: s.notificationsById
      }),
      shallow3
    );
    const loadingUserThreads = new DefaultMap(
      (queryKey) => {
        const query = JSON.parse(queryKey);
        const resource = new PaginatedResource(async (cursor) => {
          const result = await this.#client[kInternal].httpClient.getUserThreads_experimental({
            cursor,
            query
          });
          this.updateThreadifications(
            result.threads,
            result.inboxNotifications
          );
          this.permissionHints.update(result.permissionHints);
          if (this.#userThreadsLastRequestedAt === null) {
            this.#userThreadsLastRequestedAt = result.requestedAt;
          }
          return result.nextCursor;
        });
        const signal = DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          }
          const threads2 = this.outputs.threads.get().findMany(
            void 0,
            // Do _not_ filter by roomId
            query ?? {},
            "desc"
          );
          const page = result.data;
          return {
            isLoading: false,
            threads: threads2,
            hasFetchedAll: page.hasFetchedAll,
            isFetchingMore: page.isFetchingMore,
            fetchMoreError: page.fetchMoreError,
            fetchMore: page.fetchMore
          };
        }, shallow2);
        return { signal, waitUntilLoaded: resource.waitUntilLoaded };
      }
    );
    const loadingRoomThreads = new DefaultMap(
      (queryKey) => {
        const [roomId, query] = JSON.parse(queryKey);
        const resource = new PaginatedResource(async (cursor) => {
          const result = await this.#client[kInternal].httpClient.getThreads({
            roomId,
            cursor,
            query
          });
          this.updateThreadifications(
            result.threads,
            result.inboxNotifications
          );
          this.permissionHints.update(result.permissionHints);
          const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);
          if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {
            this.#roomThreadsLastRequestedAtByRoom.set(
              roomId,
              result.requestedAt
            );
          }
          return result.nextCursor;
        });
        const signal = DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          }
          const threads2 = this.outputs.threads.get().findMany(roomId, query ?? {}, "asc");
          const page = result.data;
          return {
            isLoading: false,
            threads: threads2,
            hasFetchedAll: page.hasFetchedAll,
            isFetchingMore: page.isFetchingMore,
            fetchMoreError: page.fetchMoreError,
            fetchMore: page.fetchMore
          };
        }, shallow2);
        return { signal, waitUntilLoaded: resource.waitUntilLoaded };
      }
    );
    const loadingNotifications = {
      signal: DerivedSignal.from(() => {
        const resource = this.#notificationsPaginationState;
        const result = resource.get();
        if (result.isLoading || result.error) {
          return result;
        }
        const page = result.data;
        return {
          isLoading: false,
          inboxNotifications: this.outputs.notifications.get().sortedNotifications,
          hasFetchedAll: page.hasFetchedAll,
          isFetchingMore: page.isFetchingMore,
          fetchMoreError: page.fetchMoreError,
          fetchMore: page.fetchMore
        };
      }),
      waitUntilLoaded: this.#notificationsPaginationState.waitUntilLoaded
    };
    const settingsByRoomId = new DefaultMap((roomId) => {
      const resource = new SinglePageResource(async () => {
        const room = this.#client.getRoom(roomId);
        if (room === null) {
          throw new Error(`Room '${roomId}' is not available on client`);
        }
        const result = await room.getNotificationSettings();
        this.roomNotificationSettings.update(roomId, result);
      });
      const signal = DerivedSignal.from(() => {
        const result = resource.get();
        if (result.isLoading || result.error) {
          return result;
        } else {
          return ASYNC_OK(
            "settings",
            nn(this.roomNotificationSettings.signal.get()[roomId])
          );
        }
      }, shallow3);
      return { signal, waitUntilLoaded: resource.waitUntilLoaded };
    });
    const versionsByRoomId = new DefaultMap(
      (roomId) => {
        const resource = new SinglePageResource(async () => {
          const room = this.#client.getRoom(roomId);
          if (room === null) {
            throw new Error(`Room '${roomId}' is not available on client`);
          }
          const result = await room[kInternal].listTextVersions();
          this.historyVersions.update(roomId, result.versions);
          const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);
          if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {
            this.#roomVersionsLastRequestedAtByRoom.set(
              roomId,
              result.requestedAt
            );
          }
        });
        const signal = DerivedSignal.from(() => {
          const result = resource.get();
          if (result.isLoading || result.error) {
            return result;
          } else {
            return ASYNC_OK(
              "versions",
              Object.values(this.historyVersions.signal.get()[roomId] ?? {})
            );
          }
        }, shallow3);
        return { signal, waitUntilLoaded: resource.waitUntilLoaded };
      }
    );
    this.outputs = {
      threadifications,
      threads,
      loadingRoomThreads,
      loadingUserThreads,
      notifications,
      loadingNotifications,
      settingsByRoomId,
      versionsByRoomId
    };
    autobind(this);
  }
  /**
   * Updates an existing inbox notification with a new value, replacing the
   * corresponding optimistic update.
   *
   * This will not update anything if the inbox notification ID isn't found.
   */
  markInboxNotificationRead(inboxNotificationId, readAt, optimisticId) {
    batch2(() => {
      this.optimisticUpdates.remove(optimisticId);
      this.notifications.markRead(inboxNotificationId, readAt);
    });
  }
  markAllInboxNotificationsRead(optimisticId, readAt) {
    batch2(() => {
      this.optimisticUpdates.remove(optimisticId);
      this.notifications.markAllRead(readAt);
    });
  }
  /**
   * Deletes an existing inbox notification, replacing the corresponding
   * optimistic update.
   */
  deleteInboxNotification(inboxNotificationId, optimisticId) {
    batch2(() => {
      this.optimisticUpdates.remove(optimisticId);
      this.notifications.delete(inboxNotificationId);
    });
  }
  /**
   * Deletes *all* inbox notifications, replacing the corresponding optimistic
   * update.
   */
  deleteAllInboxNotifications(optimisticId) {
    batch2(() => {
      this.optimisticUpdates.remove(optimisticId);
      this.notifications.clear();
    });
  }
  /**
   * Creates an new thread, replacing the corresponding optimistic update.
   */
  createThread(optimisticId, thread) {
    batch2(() => {
      this.optimisticUpdates.remove(optimisticId);
      this.threads.upsert(thread);
    });
  }
  /**
   * Updates an existing thread with a new value, replacing the corresponding
   * optimistic update.
   *
   * This will not update anything if:
   * - The thread ID isn't found; or
   * - The thread ID was already deleted; or
   * - The thread ID was updated more recently than the optimistic update's
   *   timestamp (if given)
   */
  #updateThread(threadId, optimisticId, callback, updatedAt) {
    batch2(() => {
      if (optimisticId !== null) {
        this.optimisticUpdates.remove(optimisticId);
      }
      const db = this.threads;
      const existing = db.get(threadId);
      if (!existing) return;
      if (!!updatedAt && existing.updatedAt > updatedAt) return;
      db.upsert(callback(existing));
    });
  }
  patchThread(threadId, optimisticId, patch, updatedAt) {
    return this.#updateThread(
      threadId,
      optimisticId,
      (thread) => ({ ...thread, ...compactObject(patch) }),
      updatedAt
    );
  }
  addReaction(threadId, optimisticId, commentId, reaction, createdAt) {
    this.#updateThread(
      threadId,
      optimisticId,
      (thread) => applyAddReaction(thread, commentId, reaction),
      createdAt
    );
  }
  removeReaction(threadId, optimisticId, commentId, emoji, userId, removedAt) {
    this.#updateThread(
      threadId,
      optimisticId,
      (thread) => applyRemoveReaction(thread, commentId, emoji, userId, removedAt),
      removedAt
    );
  }
  /**
   * Soft-deletes an existing thread by setting its `deletedAt` value,
   * replacing the corresponding optimistic update.
   *
   * This will not update anything if:
   * - The thread ID isn't found; or
   * - The thread ID was already deleted
   */
  deleteThread(threadId, optimisticId) {
    return this.#updateThread(
      threadId,
      optimisticId,
      // A deletion is actually an update of the deletedAt property internally
      (thread) => ({ ...thread, updatedAt: /* @__PURE__ */ new Date(), deletedAt: /* @__PURE__ */ new Date() })
    );
  }
  /**
   * Creates an existing comment and ensures the associated notification is
   * updated correctly, replacing the corresponding optimistic update.
   */
  createComment(newComment, optimisticId) {
    batch2(() => {
      this.optimisticUpdates.remove(optimisticId);
      const existingThread = this.threads.get(newComment.threadId);
      if (!existingThread) {
        return;
      }
      this.threads.upsert(applyUpsertComment(existingThread, newComment));
      this.notifications.updateAssociatedNotification(newComment);
    });
  }
  editComment(threadId, optimisticId, editedComment) {
    return this.#updateThread(
      threadId,
      optimisticId,
      (thread) => applyUpsertComment(thread, editedComment)
    );
  }
  deleteComment(threadId, optimisticId, commentId, deletedAt) {
    return this.#updateThread(
      threadId,
      optimisticId,
      (thread) => applyDeleteComment(thread, commentId, deletedAt),
      deletedAt
    );
  }
  updateThreadifications(threads, notifications, deletedThreads = [], deletedNotifications = []) {
    batch2(() => {
      this.threads.applyDelta(threads, deletedThreads);
      this.notifications.applyDelta(notifications, deletedNotifications);
    });
  }
  /**
   * Updates existing notification setting for a room with a new value,
   * replacing the corresponding optimistic update.
   */
  updateRoomNotificationSettings(roomId, optimisticId, settings) {
    batch2(() => {
      this.optimisticUpdates.remove(optimisticId);
      this.roomNotificationSettings.update(roomId, settings);
    });
  }
  async fetchNotificationsDeltaUpdate(signal) {
    const lastRequestedAt = this.#notificationsLastRequestedAt;
    if (lastRequestedAt === null) {
      return;
    }
    const result = await this.#client.getInboxNotificationsSince({
      since: lastRequestedAt,
      signal
    });
    if (lastRequestedAt < result.requestedAt) {
      this.#notificationsLastRequestedAt = result.requestedAt;
    }
    this.updateThreadifications(
      result.threads.updated,
      result.inboxNotifications.updated,
      result.threads.deleted,
      result.inboxNotifications.deleted
    );
  }
  async fetchRoomThreadsDeltaUpdate(roomId, signal) {
    const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);
    if (lastRequestedAt === void 0) {
      return;
    }
    const updates = await this.#client[kInternal].httpClient.getThreadsSince({
      roomId,
      since: lastRequestedAt,
      signal
    });
    this.updateThreadifications(
      updates.threads.updated,
      updates.inboxNotifications.updated,
      updates.threads.deleted,
      updates.inboxNotifications.deleted
    );
    this.permissionHints.update(updates.permissionHints);
    if (lastRequestedAt < updates.requestedAt) {
      this.#roomThreadsLastRequestedAtByRoom.set(roomId, updates.requestedAt);
    }
  }
  async fetchUserThreadsDeltaUpdate(signal) {
    const lastRequestedAt = this.#userThreadsLastRequestedAt;
    if (lastRequestedAt === null) {
      return;
    }
    const result = await this.#client[kInternal].httpClient.getUserThreadsSince_experimental({
      since: lastRequestedAt,
      signal
    });
    if (lastRequestedAt < result.requestedAt) {
      this.#notificationsLastRequestedAt = result.requestedAt;
    }
    this.updateThreadifications(
      result.threads.updated,
      result.inboxNotifications.updated,
      result.threads.deleted,
      result.inboxNotifications.deleted
    );
    this.permissionHints.update(result.permissionHints);
  }
  async fetchRoomVersionsDeltaUpdate(roomId, signal) {
    const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);
    if (lastRequestedAt === void 0) {
      return;
    }
    const room = nn(
      this.#client.getRoom(roomId),
      `Room with id ${roomId} is not available on client`
    );
    const updates = await room[kInternal].listTextVersionsSince({
      since: lastRequestedAt,
      signal
    });
    this.historyVersions.update(roomId, updates.versions);
    if (lastRequestedAt < updates.requestedAt) {
      this.#roomVersionsLastRequestedAtByRoom.set(roomId, updates.requestedAt);
    }
  }
  async refreshRoomNotificationSettings(roomId, signal) {
    const room = nn(
      this.#client.getRoom(roomId),
      `Room with id ${roomId} is not available on client`
    );
    const result = await room.getNotificationSettings({ signal });
    this.roomNotificationSettings.update(roomId, result);
  }
};
function applyOptimisticUpdates_forThreadifications(baseThreadsDB, notificationsLUT, optimisticUpdates) {
  const threadsDB = baseThreadsDB.clone();
  let notificationsById = Object.fromEntries(notificationsLUT);
  for (const optimisticUpdate of optimisticUpdates) {
    switch (optimisticUpdate.type) {
      case "create-thread": {
        threadsDB.upsert(optimisticUpdate.thread);
        break;
      }
      case "edit-thread-metadata": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        if (thread.updatedAt > optimisticUpdate.updatedAt) {
          break;
        }
        threadsDB.upsert({
          ...thread,
          updatedAt: optimisticUpdate.updatedAt,
          metadata: {
            ...thread.metadata,
            ...optimisticUpdate.metadata
          }
        });
        break;
      }
      case "mark-thread-as-resolved": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert({ ...thread, resolved: true });
        break;
      }
      case "mark-thread-as-unresolved": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert({ ...thread, resolved: false });
        break;
      }
      case "create-comment": {
        const thread = threadsDB.get(optimisticUpdate.comment.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));
        const inboxNotification = Object.values(notificationsById).find(
          (notification) => notification.kind === "thread" && notification.threadId === thread.id
        );
        if (inboxNotification === void 0) {
          break;
        }
        notificationsById[inboxNotification.id] = {
          ...inboxNotification,
          notifiedAt: optimisticUpdate.comment.createdAt,
          readAt: optimisticUpdate.comment.createdAt
        };
        break;
      }
      case "edit-comment": {
        const thread = threadsDB.get(optimisticUpdate.comment.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));
        break;
      }
      case "delete-comment": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(
          applyDeleteComment(
            thread,
            optimisticUpdate.commentId,
            optimisticUpdate.deletedAt
          )
        );
        break;
      }
      case "delete-thread": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert({
          ...thread,
          deletedAt: optimisticUpdate.deletedAt,
          updatedAt: optimisticUpdate.deletedAt,
          comments: []
        });
        break;
      }
      case "add-reaction": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(
          applyAddReaction(
            thread,
            optimisticUpdate.commentId,
            optimisticUpdate.reaction
          )
        );
        break;
      }
      case "remove-reaction": {
        const thread = threadsDB.get(optimisticUpdate.threadId);
        if (thread === void 0) break;
        threadsDB.upsert(
          applyRemoveReaction(
            thread,
            optimisticUpdate.commentId,
            optimisticUpdate.emoji,
            optimisticUpdate.userId,
            optimisticUpdate.removedAt
          )
        );
        break;
      }
      case "mark-inbox-notification-as-read": {
        const ibn = notificationsById[optimisticUpdate.inboxNotificationId];
        if (ibn === void 0) {
          break;
        }
        notificationsById[optimisticUpdate.inboxNotificationId] = {
          ...ibn,
          readAt: optimisticUpdate.readAt
        };
        break;
      }
      case "mark-all-inbox-notifications-as-read": {
        for (const id in notificationsById) {
          const ibn = notificationsById[id];
          if (ibn === void 0) {
            break;
          }
          notificationsById[id] = {
            ...ibn,
            readAt: optimisticUpdate.readAt
          };
        }
        break;
      }
      case "delete-inbox-notification": {
        delete notificationsById[optimisticUpdate.inboxNotificationId];
        break;
      }
      case "delete-all-inbox-notifications": {
        notificationsById = {};
        break;
      }
    }
  }
  const sortedNotifications = (
    // Sort so that the most recent notifications are first
    Object.values(notificationsById).filter(
      (ibn) => ibn.kind === "thread" ? threadsDB.get(ibn.threadId) !== void 0 : true
    ).sort((a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime())
  );
  return {
    sortedNotifications,
    notificationsById,
    threadsDB
  };
}
function applyOptimisticUpdates_forSettings(settingsLUT, optimisticUpdates) {
  const settingsByRoomId = Object.fromEntries(settingsLUT);
  for (const optimisticUpdate of optimisticUpdates) {
    switch (optimisticUpdate.type) {
      case "update-notification-settings": {
        const settings = settingsByRoomId[optimisticUpdate.roomId];
        if (settings === void 0) {
          break;
        }
        settingsByRoomId[optimisticUpdate.roomId] = {
          ...settings,
          ...optimisticUpdate.settings
        };
      }
    }
  }
  return settingsByRoomId;
}
function compareInboxNotifications(inboxNotificationA, inboxNotificationB) {
  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {
    return 1;
  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {
    return -1;
  }
  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {
    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;
  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {
    return inboxNotificationA.readAt ? 1 : -1;
  }
  return 0;
}
function applyUpsertComment(thread, comment) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  if (comment.threadId !== thread.id) {
    console2.warn(
      `Comment ${comment.id} does not belong to thread ${thread.id}`
    );
    return thread;
  }
  const existingComment = thread.comments.find(
    (existingComment2) => existingComment2.id === comment.id
  );
  if (existingComment === void 0) {
    const updatedAt = new Date(
      Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime())
    );
    const updatedThread = {
      ...thread,
      updatedAt,
      comments: [...thread.comments, comment]
    };
    return updatedThread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {
    const updatedComments = thread.comments.map(
      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2
    );
    const updatedThread = {
      ...thread,
      updatedAt: new Date(
        Math.max(
          thread.updatedAt.getTime(),
          comment.editedAt?.getTime() || comment.createdAt.getTime()
        )
      ),
      comments: updatedComments
    };
    return updatedThread;
  }
  return thread;
}
function applyDeleteComment(thread, commentId, deletedAt) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      deletedAt,
      // We optimistically remove the comment body and attachments when marking it as deleted
      body: void 0,
      attachments: []
    } : comment
  );
  if (updatedComments.every((comment) => comment.deletedAt !== void 0)) {
    return {
      ...thread,
      deletedAt,
      updatedAt: deletedAt
    };
  }
  return {
    ...thread,
    updatedAt: deletedAt,
    comments: updatedComments
  };
}
function applyAddReaction(thread, commentId, reaction) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      reactions: upsertReaction(comment.reactions, reaction)
    } : comment
  );
  return {
    ...thread,
    updatedAt: new Date(
      Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())
    ),
    comments: updatedComments
  };
}
function applyRemoveReaction(thread, commentId, emoji, userId, removedAt) {
  if (thread.deletedAt !== void 0) {
    return thread;
  }
  const existingComment = thread.comments.find(
    (comment) => comment.id === commentId
  );
  if (existingComment === void 0) {
    return thread;
  }
  if (existingComment.deletedAt !== void 0) {
    return thread;
  }
  const updatedComments = thread.comments.map(
    (comment) => comment.id === commentId ? {
      ...comment,
      reactions: comment.reactions.map(
        (reaction) => reaction.emoji === emoji ? {
          ...reaction,
          users: reaction.users.filter((user) => user.id !== userId)
        } : reaction
      ).filter((reaction) => reaction.users.length > 0)
      // Remove reactions with no users left
    } : comment
  );
  return {
    ...thread,
    updatedAt: new Date(
      Math.max(removedAt.getTime(), thread.updatedAt.getTime())
    ),
    comments: updatedComments
  };
}
function upsertReaction(reactions, reaction) {
  const existingReaction = reactions.find(
    (existingReaction2) => existingReaction2.emoji === reaction.emoji
  );
  if (existingReaction === void 0) {
    return [
      ...reactions,
      {
        emoji: reaction.emoji,
        createdAt: reaction.createdAt,
        users: [{ id: reaction.userId }]
      }
    ];
  }
  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {
    return reactions.map(
      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {
        ...existingReaction2,
        users: [...existingReaction2.users, { id: reaction.userId }]
      } : existingReaction2
    );
  }
  return reactions;
}

// src/liveblocks.tsx
import { jsx } from "react/jsx-runtime";
var ClientContext = createContext2(null);
function missingUserError(userId) {
  return new Error(`resolveUsers didn't return anything for user '${userId}'`);
}
function missingRoomInfoError(roomId) {
  return new Error(
    `resolveRoomsInfo didn't return anything for room '${roomId}'`
  );
}
function identity2(x) {
  return x;
}
var _umbrellaStores = /* @__PURE__ */ new WeakMap();
var _extras = /* @__PURE__ */ new WeakMap();
var _bundles = /* @__PURE__ */ new WeakMap();
function selectorFor_useUnreadInboxNotificationsCount(result) {
  if (!result.inboxNotifications) {
    return result;
  }
  return ASYNC_OK(
    "count",
    count(
      result.inboxNotifications,
      (n) => n.readAt === null || n.readAt < n.notifiedAt
    )
  );
}
function selectorFor_useUser(state, userId) {
  if (state === void 0 || state?.isLoading) {
    return state ?? { isLoading: true };
  }
  if (state.error) {
    return state;
  }
  if (!state.data) {
    return {
      isLoading: false,
      error: missingUserError(userId)
    };
  }
  return {
    isLoading: false,
    user: state.data
  };
}
function selectorFor_useRoomInfo(state, roomId) {
  if (state === void 0 || state?.isLoading) {
    return state ?? { isLoading: true };
  }
  if (state.error) {
    return state;
  }
  if (!state.data) {
    return {
      isLoading: false,
      error: missingRoomInfoError(roomId)
    };
  }
  return {
    isLoading: false,
    info: state.data
  };
}
function getOrCreateContextBundle(client) {
  let bundle = _bundles.get(client);
  if (!bundle) {
    bundle = makeLiveblocksContextBundle(client);
    _bundles.set(client, bundle);
  }
  return bundle;
}
function getUmbrellaStoreForClient(client) {
  let store = _umbrellaStores.get(client);
  if (!store) {
    store = new UmbrellaStore(client);
    _umbrellaStores.set(client, store);
  }
  return store;
}
function getLiveblocksExtrasForClient(client) {
  let extras = _extras.get(client);
  if (!extras) {
    extras = makeLiveblocksExtrasForClient(client);
    _extras.set(client, extras);
  }
  return extras;
}
function makeLiveblocksExtrasForClient(client) {
  const store = getUmbrellaStoreForClient(client);
  const notificationsPoller = makePoller(
    async (signal) => {
      try {
        return await store.fetchNotificationsDeltaUpdate(signal);
      } catch (err) {
        console.warn(`Polling new inbox notifications failed: ${String(err)}`);
        throw err;
      }
    },
    config.NOTIFICATIONS_POLL_INTERVAL,
    { maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME }
  );
  const userThreadsPoller = makePoller(
    async (signal) => {
      try {
        return await store.fetchUserThreadsDeltaUpdate(signal);
      } catch (err) {
        console.warn(`Polling new user threads failed: ${String(err)}`);
        throw err;
      }
    },
    config.USER_THREADS_POLL_INTERVAL,
    { maxStaleTimeMs: config.USER_THREADS_MAX_STALE_TIME }
  );
  return {
    store,
    notificationsPoller,
    userThreadsPoller
  };
}
function makeLiveblocksContextBundle(client) {
  const useInboxNotificationThread2 = (inboxNotificationId) => useInboxNotificationThread_withClient(client, inboxNotificationId);
  const useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client);
  const useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client);
  const useDeleteInboxNotification2 = () => useDeleteInboxNotification_withClient(client);
  const useDeleteAllInboxNotifications2 = () => useDeleteAllInboxNotifications_withClient(client);
  function LiveblocksProvider2(props) {
    useEnsureNoLiveblocksProvider();
    return /* @__PURE__ */ jsx(ClientContext.Provider, { value: client, children: props.children });
  }
  const shared = createSharedContext(client);
  const bundle = {
    LiveblocksProvider: LiveblocksProvider2,
    useInboxNotifications: () => useInboxNotifications_withClient(client, identity2, shallow4),
    useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCount_withClient(client),
    useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
    useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
    useDeleteInboxNotification: useDeleteInboxNotification2,
    useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
    useInboxNotificationThread: useInboxNotificationThread2,
    useUserThreads_experimental,
    ...shared.classic,
    suspense: {
      LiveblocksProvider: LiveblocksProvider2,
      useInboxNotifications: () => useInboxNotificationsSuspense_withClient(client),
      useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCountSuspense_withClient(client),
      useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
      useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
      useDeleteInboxNotification: useDeleteInboxNotification2,
      useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
      useInboxNotificationThread: useInboxNotificationThread2,
      useUserThreads_experimental: useUserThreadsSuspense_experimental,
      ...shared.suspense
    }
  };
  return bundle;
}
function useInboxNotifications_withClient(client, selector, isEqual) {
  const { store, notificationsPoller: poller } = getLiveblocksExtrasForClient(client);
  useEffect3(
    () => void store.outputs.loadingNotifications.waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  useEffect3(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => {
      poller.dec();
    };
  }, [poller]);
  return useSignal(
    store.outputs.loadingNotifications.signal,
    selector,
    isEqual
  );
}
function useInboxNotificationsSuspense_withClient(client) {
  ensureNotServerSide();
  const store = getLiveblocksExtrasForClient(client).store;
  use(store.outputs.loadingNotifications.waitUntilLoaded());
  const result = useInboxNotifications_withClient(client, identity2, shallow4);
  assert(!result.error, "Did not expect error");
  assert(!result.isLoading, "Did not expect loading");
  return result;
}
function useUnreadInboxNotificationsCount_withClient(client) {
  return useInboxNotifications_withClient(
    client,
    selectorFor_useUnreadInboxNotificationsCount,
    shallow4
  );
}
function useUnreadInboxNotificationsCountSuspense_withClient(client) {
  ensureNotServerSide();
  const store = getLiveblocksExtrasForClient(client).store;
  use(store.outputs.loadingNotifications.waitUntilLoaded());
  const result = useUnreadInboxNotificationsCount_withClient(client);
  assert(!result.isLoading, "Did not expect loading");
  assert(!result.error, "Did not expect error");
  return result;
}
function useMarkInboxNotificationAsRead_withClient(client) {
  return useCallback2(
    (inboxNotificationId) => {
      const { store } = getLiveblocksExtrasForClient(client);
      const readAt = /* @__PURE__ */ new Date();
      const optimisticId = store.optimisticUpdates.add({
        type: "mark-inbox-notification-as-read",
        inboxNotificationId,
        readAt
      });
      client.markInboxNotificationAsRead(inboxNotificationId).then(
        () => {
          store.markInboxNotificationRead(
            inboxNotificationId,
            readAt,
            optimisticId
          );
        },
        (err) => {
          store.optimisticUpdates.remove(optimisticId);
          client[kInternal2].emitError(
            {
              type: "MARK_INBOX_NOTIFICATION_AS_READ_ERROR",
              inboxNotificationId
            },
            err
          );
        }
      );
    },
    [client]
  );
}
function useMarkAllInboxNotificationsAsRead_withClient(client) {
  return useCallback2(() => {
    const { store } = getLiveblocksExtrasForClient(client);
    const readAt = /* @__PURE__ */ new Date();
    const optimisticId = store.optimisticUpdates.add({
      type: "mark-all-inbox-notifications-as-read",
      readAt
    });
    client.markAllInboxNotificationsAsRead().then(
      () => {
        store.markAllInboxNotificationsRead(optimisticId, readAt);
      },
      (err) => {
        store.optimisticUpdates.remove(optimisticId);
        client[kInternal2].emitError(
          // No roomId, threadId, commentId to include for this error
          { type: "MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR" },
          err
        );
      }
    );
  }, [client]);
}
function useDeleteInboxNotification_withClient(client) {
  return useCallback2(
    (inboxNotificationId) => {
      const { store } = getLiveblocksExtrasForClient(client);
      const deletedAt = /* @__PURE__ */ new Date();
      const optimisticId = store.optimisticUpdates.add({
        type: "delete-inbox-notification",
        inboxNotificationId,
        deletedAt
      });
      client.deleteInboxNotification(inboxNotificationId).then(
        () => {
          store.deleteInboxNotification(inboxNotificationId, optimisticId);
        },
        (err) => {
          store.optimisticUpdates.remove(optimisticId);
          client[kInternal2].emitError(
            { type: "DELETE_INBOX_NOTIFICATION_ERROR", inboxNotificationId },
            err
          );
        }
      );
    },
    [client]
  );
}
function useDeleteAllInboxNotifications_withClient(client) {
  return useCallback2(() => {
    const { store } = getLiveblocksExtrasForClient(client);
    const deletedAt = /* @__PURE__ */ new Date();
    const optimisticId = store.optimisticUpdates.add({
      type: "delete-all-inbox-notifications",
      deletedAt
    });
    client.deleteAllInboxNotifications().then(
      () => {
        store.deleteAllInboxNotifications(optimisticId);
      },
      (err) => {
        store.optimisticUpdates.remove(optimisticId);
        client[kInternal2].emitError(
          { type: "DELETE_ALL_INBOX_NOTIFICATIONS_ERROR" },
          err
        );
      }
    );
  }, [client]);
}
function useInboxNotificationThread_withClient(client, inboxNotificationId) {
  const { store } = getLiveblocksExtrasForClient(client);
  return useSignal(
    store.outputs.threadifications,
    useCallback2(
      (state) => {
        const inboxNotification = state.notificationsById[inboxNotificationId] ?? raise(
          `Inbox notification with ID "${inboxNotificationId}" not found`
        );
        if (inboxNotification.kind !== "thread") {
          raise(
            `Inbox notification with ID "${inboxNotificationId}" is not of kind "thread"`
          );
        }
        const thread = state.threadsDB.get(inboxNotification.threadId) ?? raise(
          `Thread with ID "${inboxNotification.threadId}" not found, this inbox notification might not be of kind "thread"`
        );
        return thread;
      },
      [inboxNotificationId]
    )
  );
}
function useUser_withClient(client, userId) {
  const usersStore = client[kInternal2].usersStore;
  const getUserState = useCallback2(
    () => usersStore.getItemState(userId),
    [usersStore, userId]
  );
  const selector = useCallback2(
    (state) => selectorFor_useUser(state, userId),
    [userId]
  );
  const result = useSyncExternalStoreWithSelector(
    usersStore.subscribe,
    getUserState,
    getUserState,
    selector,
    shallow4
  );
  useEffect3(
    () => void usersStore.enqueue(userId)
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call usersStore.enqueue on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger evaluation
    //    of the userId.
    // 2. All other subsequent renders now are a no-op (from the implementation
    //    of .enqueue)
    // 3. If ever the userId gets invalidated, the user would be fetched again.
  );
  return result;
}
function useUserSuspense_withClient(client, userId) {
  const usersStore = client[kInternal2].usersStore;
  const getUserState = useCallback2(
    () => usersStore.getItemState(userId),
    [usersStore, userId]
  );
  const userState = getUserState();
  if (!userState || userState.isLoading) {
    throw usersStore.enqueue(userId);
  }
  if (userState.error) {
    throw userState.error;
  }
  if (!userState.data) {
    throw missingUserError(userId);
  }
  const state = useSyncExternalStore2(
    usersStore.subscribe,
    getUserState,
    getUserState
  );
  assert(state !== void 0, "Unexpected missing state");
  assert(!state.isLoading, "Unexpected loading state");
  assert(!state.error, "Unexpected error state");
  return {
    isLoading: false,
    user: state.data,
    error: void 0
  };
}
function useRoomInfo_withClient(client, roomId) {
  const roomsInfoStore = client[kInternal2].roomsInfoStore;
  const getRoomInfoState = useCallback2(
    () => roomsInfoStore.getItemState(roomId),
    [roomsInfoStore, roomId]
  );
  const selector = useCallback2(
    (state) => selectorFor_useRoomInfo(state, roomId),
    [roomId]
  );
  const result = useSyncExternalStoreWithSelector(
    roomsInfoStore.subscribe,
    getRoomInfoState,
    getRoomInfoState,
    selector,
    shallow4
  );
  useEffect3(
    () => void roomsInfoStore.enqueue(roomId)
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call roomsInfoStore.enqueue on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger evaluation
    //    of the roomId.
    // 2. All other subsequent renders now are a no-op (from the implementation
    //    of .enqueue)
    // 3. If ever the roomId gets invalidated, the room info would be fetched again.
  );
  return result;
}
function useRoomInfoSuspense_withClient(client, roomId) {
  const roomsInfoStore = client[kInternal2].roomsInfoStore;
  const getRoomInfoState = useCallback2(
    () => roomsInfoStore.getItemState(roomId),
    [roomsInfoStore, roomId]
  );
  const roomInfoState = getRoomInfoState();
  if (!roomInfoState || roomInfoState.isLoading) {
    throw roomsInfoStore.enqueue(roomId);
  }
  if (roomInfoState.error) {
    throw roomInfoState.error;
  }
  if (!roomInfoState.data) {
    throw missingRoomInfoError(roomId);
  }
  const state = useSyncExternalStore2(
    roomsInfoStore.subscribe,
    getRoomInfoState,
    getRoomInfoState
  );
  assert(state !== void 0, "Unexpected missing state");
  assert(!state.isLoading, "Unexpected loading state");
  assert(!state.error, "Unexpected error state");
  assert(state.data !== void 0, "Unexpected missing room info data");
  return {
    isLoading: false,
    info: state.data,
    error: void 0
  };
}
function createSharedContext(client) {
  const useClient2 = () => client;
  function useSyncStatus2(options) {
    return useSyncStatus_withClient(client, options);
  }
  return {
    classic: {
      useClient: useClient2,
      useUser: (userId) => useUser_withClient(client, userId),
      useRoomInfo: (roomId) => useRoomInfo_withClient(client, roomId),
      useIsInsideRoom,
      useErrorListener,
      useSyncStatus: useSyncStatus2
    },
    suspense: {
      useClient: useClient2,
      useUser: (userId) => useUserSuspense_withClient(client, userId),
      useRoomInfo: (roomId) => useRoomInfoSuspense_withClient(client, roomId),
      useIsInsideRoom,
      useErrorListener,
      useSyncStatus: useSyncStatus2
    }
  };
}
function useEnsureNoLiveblocksProvider(options) {
  const existing = useClientOrNull();
  if (!options?.allowNesting && existing !== null) {
    throw new Error(
      "You cannot nest multiple LiveblocksProvider instances in the same React tree."
    );
  }
}
function useClientOrNull() {
  return useContext2(ClientContext);
}
function useClient() {
  return useClientOrNull() ?? raise("LiveblocksProvider is missing from the React tree.");
}
function LiveblocksProviderWithClient(props) {
  useEnsureNoLiveblocksProvider(props);
  return /* @__PURE__ */ jsx(ClientContext.Provider, { value: props.client, children: props.children });
}
function LiveblocksProvider(props) {
  const { children, ...o } = props;
  const options = {
    publicApiKey: useInitial(o.publicApiKey),
    throttle: useInitial(o.throttle),
    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),
    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),
    polyfills: useInitial(o.polyfills),
    largeMessageStrategy: useInitial(o.largeMessageStrategy),
    unstable_fallbackToHTTP: useInitial(o.unstable_fallbackToHTTP),
    unstable_streamData: useInitial(o.unstable_streamData),
    preventUnsavedChanges: useInitial(o.preventUnsavedChanges),
    authEndpoint: useInitialUnlessFunction(o.authEndpoint),
    resolveMentionSuggestions: useInitialUnlessFunction(
      o.resolveMentionSuggestions
    ),
    resolveUsers: useInitialUnlessFunction(o.resolveUsers),
    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),
    baseUrl: useInitial(
      // @ts-expect-error - Hidden config options
      o.baseUrl
    ),
    enableDebugLogging: useInitial(
      // @ts-expect-error - Hidden config options
      o.enableDebugLogging
    )
  };
  const client = useMemo2(() => createClient(options), []);
  return /* @__PURE__ */ jsx(LiveblocksProviderWithClient, { client, children });
}
function createLiveblocksContext(client) {
  return getOrCreateContextBundle(client);
}
function useUserThreads_experimental(options = {}) {
  const client = useClient();
  const { store, userThreadsPoller: poller } = getLiveblocksExtrasForClient(client);
  const queryKey = makeUserThreadsQueryKey(options.query);
  useEffect3(
    () => void store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  useEffect3(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => {
      poller.dec();
    };
  }, [poller]);
  return useSignal(
    store.outputs.loadingUserThreads.getOrCreate(queryKey).signal
  );
}
function useUserThreadsSuspense_experimental(options = {}) {
  ensureNotServerSide();
  const client = useClient();
  const { store } = getLiveblocksExtrasForClient(client);
  const queryKey = makeUserThreadsQueryKey(options.query);
  use(store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded());
  const result = useUserThreads_experimental(options);
  assert(!result.error, "Did not expect error");
  assert(!result.isLoading, "Did not expect loading");
  return result;
}
function useInboxNotifications() {
  return useInboxNotifications_withClient(useClient(), identity2, shallow4);
}
function useInboxNotificationsSuspense() {
  return useInboxNotificationsSuspense_withClient(useClient());
}
function useInboxNotificationThread(inboxNotificationId) {
  return useInboxNotificationThread_withClient(
    useClient(),
    inboxNotificationId
  );
}
function useMarkAllInboxNotificationsAsRead() {
  return useMarkAllInboxNotificationsAsRead_withClient(useClient());
}
function useMarkInboxNotificationAsRead() {
  return useMarkInboxNotificationAsRead_withClient(useClient());
}
function useDeleteAllInboxNotifications() {
  return useDeleteAllInboxNotifications_withClient(useClient());
}
function useDeleteInboxNotification() {
  return useDeleteInboxNotification_withClient(useClient());
}
function useUnreadInboxNotificationsCount() {
  return useUnreadInboxNotificationsCount_withClient(useClient());
}
function useUnreadInboxNotificationsCountSuspense() {
  return useUnreadInboxNotificationsCountSuspense_withClient(useClient());
}
function useUser(userId) {
  const client = useClient();
  return useUser_withClient(client, userId);
}
function useUserSuspense(userId) {
  const client = useClient();
  return useUserSuspense_withClient(client, userId);
}
function useRoomInfo(roomId) {
  return useRoomInfo_withClient(useClient(), roomId);
}
function useRoomInfoSuspense(roomId) {
  return useRoomInfoSuspense_withClient(useClient(), roomId);
}
var _useInboxNotificationThread = useInboxNotificationThread;
var _useUser = useUser;
var _useUserSuspense = useUserSuspense;
var _useUserThreads_experimental = useUserThreads_experimental;
var _useUserThreadsSuspense_experimental = useUserThreadsSuspense_experimental;
function useSyncStatus_withClient(client, options) {
  const smooth = useInitial(options?.smooth ?? false);
  if (smooth) {
    return useSyncStatusSmooth_withClient(client);
  } else {
    return useSyncStatusImmediate_withClient(client);
  }
}
function useSyncStatusImmediate_withClient(client) {
  return useSyncExternalStore2(
    client.events.syncStatus.subscribe,
    client.getSyncStatus,
    client.getSyncStatus
  );
}
function useSyncStatusSmooth_withClient(client) {
  const getter = client.getSyncStatus;
  const [status, setStatus] = useState(getter);
  const oldStatus = useLatest(getter());
  useEffect3(() => {
    let timeoutId;
    const unsub = client.events.syncStatus.subscribe(() => {
      const newStatus = getter();
      if (oldStatus.current === "synchronizing" && newStatus === "synchronized") {
        timeoutId = setTimeout(() => setStatus(newStatus), config.SMOOTH_DELAY);
      } else {
        clearTimeout(timeoutId);
        setStatus(newStatus);
      }
    });
    return () => {
      clearTimeout(timeoutId);
      unsub();
    };
  }, [client, getter, oldStatus]);
  return status;
}
function useSyncStatus(options) {
  return useSyncStatus_withClient(useClient(), options);
}
function useErrorListener(callback) {
  const client = useClient();
  const savedCallback = useLatest(callback);
  useEffect3(
    () => client.events.error.subscribe((e) => savedCallback.current(e)),
    [client, savedCallback]
  );
}

// src/room.tsx
import { shallow as shallow5 } from "@liveblocks/client";
import {
  assert as assert2,
  console as console3,
  createCommentId,
  createThreadId,
  DefaultMap as DefaultMap2,
  errorIf,
  HttpError,
  kInternal as kInternal3,
  makePoller as makePoller2,
  ServerMsgCode
} from "@liveblocks/core";
import {
  useCallback as useCallback3,
  useEffect as useEffect5,
  useMemo as useMemo3,
  useRef as useRef3,
  useState as useState2,
  useSyncExternalStore as useSyncExternalStore3,
  version as reactVersion
} from "react";

// src/use-scroll-to-comment-on-load-effect.ts
import { useEffect as useEffect4 } from "react";
function handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {
  if (shouldScrollOnLoad === false) return;
  if (!state.threads) return;
  const isWindowDefined = typeof window !== "undefined";
  if (!isWindowDefined) return;
  const hash = window.location.hash;
  const commentId = hash.slice(1);
  if (!commentId.startsWith("cm_")) return;
  const comment = document.getElementById(commentId);
  if (comment === null) return;
  const comments = state.threads.flatMap((thread) => thread.comments);
  const isCommentInThreads = comments.some(
    (comment2) => comment2.id === commentId
  );
  if (!isCommentInThreads) return;
  comment.scrollIntoView();
}
function useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {
  useEffect4(
    () => {
      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once
    [state.isLoading]
  );
}

// src/room.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
var noop3 = () => {
};
var identity3 = (x) => x;
var STABLE_EMPTY_LIST = Object.freeze([]);
function alwaysEmptyList() {
  return STABLE_EMPTY_LIST;
}
function alwaysNull() {
  return null;
}
function selectorFor_useOthersConnectionIds(others) {
  return others.map((user) => user.connectionId);
}
function makeMutationContext(room) {
  const cannotUseUntil = "This mutation cannot be used until";
  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;
  const needsStorage = `${cannotUseUntil} storage has been loaded`;
  return {
    get storage() {
      const mutableRoot = room.getStorageSnapshot();
      if (mutableRoot === null) {
        throw new Error(needsStorage);
      }
      return mutableRoot;
    },
    get self() {
      const self = room.getSelf();
      if (self === null) {
        throw new Error(needsPresence);
      }
      return self;
    },
    get others() {
      const others = room.getOthers();
      if (room.getSelf() === null) {
        throw new Error(needsPresence);
      }
      return others;
    },
    setMyPresence: room.updatePresence
  };
}
function getCurrentUserId(client) {
  const userId = client[kInternal3].currentUserId.get();
  if (userId === void 0) {
    return "anonymous";
  }
  return userId;
}
var _extras2 = /* @__PURE__ */ new WeakMap();
var _bundles2 = /* @__PURE__ */ new WeakMap();
function getOrCreateRoomContextBundle(client) {
  let bundle = _bundles2.get(client);
  if (!bundle) {
    bundle = makeRoomContextBundle(client);
    _bundles2.set(client, bundle);
  }
  return bundle;
}
function getRoomExtrasForClient(client) {
  let extras = _extras2.get(client);
  if (!extras) {
    extras = makeRoomExtrasForClient(client);
    _extras2.set(client, extras);
  }
  return extras;
}
function makeRoomExtrasForClient(client) {
  const store = getUmbrellaStoreForClient(client);
  function onMutationFailure(optimisticId, context, innerError) {
    store.optimisticUpdates.remove(optimisticId);
    if (innerError instanceof HttpError) {
      if (innerError.status === 403) {
        const detailedMessage = [
          innerError.message,
          innerError.details?.suggestion,
          innerError.details?.docs
        ].filter(Boolean).join("\n");
        console3.error(detailedMessage);
      }
      client[kInternal3].emitError(context, innerError);
    } else {
      throw innerError;
    }
  }
  const threadsPollersByRoomId = new DefaultMap2(
    (roomId) => makePoller2(
      async (signal) => {
        try {
          return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);
        } catch (err) {
          console3.warn(`Polling new threads for '${roomId}' failed: ${String(err)}`);
          throw err;
        }
      },
      config.ROOM_THREADS_POLL_INTERVAL,
      { maxStaleTimeMs: config.ROOM_THREADS_MAX_STALE_TIME }
    )
  );
  const versionsPollersByRoomId = new DefaultMap2(
    (roomId) => makePoller2(
      async (signal) => {
        try {
          return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);
        } catch (err) {
          console3.warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`);
          throw err;
        }
      },
      config.HISTORY_VERSIONS_POLL_INTERVAL,
      { maxStaleTimeMs: config.HISTORY_VERSIONS_MAX_STALE_TIME }
    )
  );
  const roomNotificationSettingsPollersByRoomId = new DefaultMap2(
    (roomId) => makePoller2(
      async (signal) => {
        try {
          return await store.refreshRoomNotificationSettings(roomId, signal);
        } catch (err) {
          console3.warn(`Polling notification settings for '${roomId}' failed: ${String(err)}`);
          throw err;
        }
      },
      config.NOTIFICATION_SETTINGS_POLL_INTERVAL,
      { maxStaleTimeMs: config.NOTIFICATION_SETTINGS_MAX_STALE_TIME }
    )
  );
  return {
    store,
    onMutationFailure,
    getOrCreateThreadsPollerForRoomId: threadsPollersByRoomId.getOrCreate.bind(
      threadsPollersByRoomId
    ),
    getOrCreateVersionsPollerForRoomId: versionsPollersByRoomId.getOrCreate.bind(versionsPollersByRoomId),
    getOrCreateNotificationsSettingsPollerForRoomId: roomNotificationSettingsPollersByRoomId.getOrCreate.bind(
      roomNotificationSettingsPollersByRoomId
    )
  };
}
function makeRoomContextBundle(client) {
  function RoomProvider_withImplicitLiveblocksProvider(props) {
    return /* @__PURE__ */ jsx2(LiveblocksProviderWithClient, { client, allowNesting: true, children: /* @__PURE__ */ jsx2(RoomProvider, { ...props }) });
  }
  const shared = createSharedContext(client);
  const bundle = {
    RoomContext,
    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
    useRoom,
    useStatus,
    useStorageStatus,
    useBatch,
    useBroadcastEvent,
    useOthersListener,
    useLostConnectionListener,
    useEventListener,
    useHistory,
    useUndo,
    useRedo,
    useCanRedo,
    useCanUndo,
    useStorageRoot,
    useStorage,
    useSelf,
    useMyPresence,
    useUpdateMyPresence,
    useOthers,
    useOthersMapped,
    useOthersConnectionIds,
    useOther,
    useMutation,
    useThreads,
    useCreateThread,
    useDeleteThread,
    useEditThreadMetadata,
    useMarkThreadAsResolved,
    useMarkThreadAsUnresolved,
    useCreateComment,
    useEditComment,
    useDeleteComment,
    useAddReaction,
    useRemoveReaction,
    useMarkThreadAsRead,
    useThreadSubscription,
    useAttachmentUrl,
    useHistoryVersions,
    useHistoryVersionData,
    useRoomNotificationSettings,
    useUpdateRoomNotificationSettings,
    ...shared.classic,
    suspense: {
      RoomContext,
      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
      useRoom,
      useStatus,
      useStorageStatus: useStorageStatusSuspense,
      useBatch,
      useBroadcastEvent,
      useOthersListener,
      useLostConnectionListener,
      useEventListener,
      useHistory,
      useUndo,
      useRedo,
      useCanRedo,
      useCanUndo,
      useStorageRoot,
      useStorage: useStorageSuspense,
      useSelf: useSelfSuspense,
      useMyPresence,
      useUpdateMyPresence,
      useOthers: useOthersSuspense,
      useOthersMapped: useOthersMappedSuspense,
      useOthersConnectionIds: useOthersConnectionIdsSuspense,
      useOther: useOtherSuspense,
      useMutation,
      useThreads: useThreadsSuspense,
      useCreateThread,
      useDeleteThread,
      useEditThreadMetadata,
      useMarkThreadAsResolved,
      useMarkThreadAsUnresolved,
      useCreateComment,
      useEditComment,
      useDeleteComment,
      useAddReaction,
      useRemoveReaction,
      useMarkThreadAsRead,
      useThreadSubscription,
      useAttachmentUrl: useAttachmentUrlSuspense,
      // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,
      useHistoryVersions: useHistoryVersionsSuspense,
      useRoomNotificationSettings: useRoomNotificationSettingsSuspense,
      useUpdateRoomNotificationSettings,
      ...shared.suspense
    }
  };
  return Object.defineProperty(bundle, kInternal3, {
    enumerable: false
  });
}
function RoomProvider(props) {
  const client = useClient();
  const [cache] = useState2(
    () => /* @__PURE__ */ new Map()
  );
  const stableEnterRoom = useCallback3(
    (roomId, options) => {
      const cached = cache.get(roomId);
      if (cached) return cached;
      const rv = client.enterRoom(roomId, options);
      const origLeave = rv.leave;
      rv.leave = () => {
        origLeave();
        cache.delete(roomId);
      };
      cache.set(roomId, rv);
      return rv;
    },
    [client, cache]
  );
  return /* @__PURE__ */ jsx2(
    RoomProviderInner,
    {
      ...props,
      stableEnterRoom
    }
  );
}
function RoomProviderInner(props) {
  const client = useClient();
  const { id: roomId, stableEnterRoom } = props;
  if (process.env.NODE_ENV !== "production") {
    if (!roomId) {
      throw new Error(
        "RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required"
      );
    }
    if (typeof roomId !== "string") {
      throw new Error("RoomProvider id property should be a string.");
    }
    const majorReactVersion = parseInt(reactVersion) || 1;
    const requiredVersion = 18;
    errorIf(
      majorReactVersion < requiredVersion,
      `React ${requiredVersion} or higher is required (you\u2019re on ${reactVersion})`
    );
  }
  const frozenProps = useInitial({
    initialPresence: props.initialPresence,
    initialStorage: props.initialStorage,
    autoConnect: props.autoConnect ?? typeof window !== "undefined"
  });
  const [{ room }, setRoomLeavePair] = useState2(
    () => stableEnterRoom(roomId, {
      ...frozenProps,
      autoConnect: false
      // Deliberately using false here on the first render, see below
    })
  );
  useEffect5(() => {
    const { store } = getRoomExtrasForClient(client);
    async function handleCommentEvent(message) {
      if (message.type === ServerMsgCode.THREAD_DELETED) {
        store.deleteThread(message.threadId, null);
        return;
      }
      const info = await room.getThread(message.threadId);
      if (!info.thread) {
        store.deleteThread(message.threadId, null);
        return;
      }
      const { thread, inboxNotification: maybeNotification } = info;
      const existingThread = store.outputs.threads.get().getEvenIfDeleted(message.threadId);
      switch (message.type) {
        case ServerMsgCode.COMMENT_EDITED:
        case ServerMsgCode.THREAD_METADATA_UPDATED:
        case ServerMsgCode.THREAD_UPDATED:
        case ServerMsgCode.COMMENT_REACTION_ADDED:
        case ServerMsgCode.COMMENT_REACTION_REMOVED:
        case ServerMsgCode.COMMENT_DELETED:
          if (!existingThread) break;
          store.updateThreadifications(
            [thread],
            maybeNotification ? [maybeNotification] : []
          );
          break;
        case ServerMsgCode.COMMENT_CREATED:
          store.updateThreadifications(
            [thread],
            maybeNotification ? [maybeNotification] : []
          );
          break;
        default:
          break;
      }
    }
    return room.events.comments.subscribe(
      (message) => void handleCommentEvent(message)
    );
  }, [client, room]);
  useEffect5(() => {
    const pair = stableEnterRoom(roomId, frozenProps);
    setRoomLeavePair(pair);
    const { room: room2, leave } = pair;
    if (frozenProps.autoConnect) {
      room2.connect();
    }
    return () => {
      leave();
    };
  }, [roomId, frozenProps, stableEnterRoom]);
  return /* @__PURE__ */ jsx2(RoomContext.Provider, { value: room, children: props.children });
}
function useRoom() {
  const room = useRoomOrNull();
  if (room === null) {
    throw new Error("RoomProvider is missing from the React tree.");
  }
  return room;
}
function useStatus() {
  const room = useRoom();
  const subscribe = room.events.status.subscribe;
  const getSnapshot = room.getStatus;
  const getServerSnapshot = room.getStatus;
  return useSyncExternalStore3(subscribe, getSnapshot, getServerSnapshot);
}
function useReportTextEditor(editor, rootKey) {
  const isReported = useRef3(false);
  const room = useRoom();
  useEffect5(() => {
    if (isReported.current) {
      return;
    }
    const unsubscribe = room.events.status.subscribe((status) => {
      if (status === "connected" && !isReported.current) {
        isReported.current = true;
        void room[kInternal3].reportTextEditor(editor, rootKey);
      }
    });
    return unsubscribe;
  }, [room, editor, rootKey]);
}
function useYjsProvider() {
  const room = useRoom();
  const subscribe = useCallback3(
    (onStoreChange) => {
      return room[kInternal3].yjsProviderDidChange.subscribe(onStoreChange);
    },
    [room]
  );
  const getSnapshot = useCallback3(() => {
    return room[kInternal3].getYjsProvider();
  }, [room]);
  return useSyncExternalStore3(subscribe, getSnapshot, getSnapshot);
}
function useCreateTextMention() {
  const room = useRoom();
  return useCallback3(
    (userId, mentionId) => {
      room[kInternal3].createTextMention(userId, mentionId).catch((err) => {
        console3.error(
          `Cannot create text mention for user '${userId}' and mention '${mentionId}'`,
          err
        );
      });
    },
    [room]
  );
}
function useDeleteTextMention() {
  const room = useRoom();
  return useCallback3(
    (mentionId) => {
      room[kInternal3].deleteTextMention(mentionId).catch((err) => {
        console3.error(`Cannot delete text mention '${mentionId}'`, err);
      });
    },
    [room]
  );
}
function useResolveMentionSuggestions() {
  const client = useClient();
  return client[kInternal3].resolveMentionSuggestions;
}
function useMentionSuggestionsCache() {
  const client = useClient();
  return client[kInternal3].mentionSuggestionsCache;
}
function useStorageStatus(options) {
  const smooth = useInitial(options?.smooth ?? false);
  if (smooth) {
    return useStorageStatusSmooth();
  } else {
    return useStorageStatusImmediate();
  }
}
function useStorageStatusImmediate() {
  const room = useRoom();
  const subscribe = room.events.storageStatus.subscribe;
  const getSnapshot = room.getStorageStatus;
  const getServerSnapshot = room.getStorageStatus;
  return useSyncExternalStore3(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageStatusSmooth() {
  const room = useRoom();
  const [status, setStatus] = useState2(room.getStorageStatus);
  const oldStatus = useLatest(room.getStorageStatus());
  useEffect5(() => {
    let timeoutId;
    const unsub = room.events.storageStatus.subscribe((newStatus) => {
      if (oldStatus.current === "synchronizing" && newStatus === "synchronized") {
        timeoutId = setTimeout(() => setStatus(newStatus), config.SMOOTH_DELAY);
      } else {
        clearTimeout(timeoutId);
        setStatus(newStatus);
      }
    });
    return () => {
      clearTimeout(timeoutId);
      unsub();
    };
  }, [room, oldStatus]);
  return status;
}
function useBatch() {
  return useRoom().batch;
}
function useBroadcastEvent() {
  const room = useRoom();
  return useCallback3(
    (event, options = { shouldQueueEventIfNotReady: false }) => {
      room.broadcastEvent(event, options);
    },
    [room]
  );
}
function useOthersListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  useEffect5(
    () => room.events.others.subscribe((event) => savedCallback.current(event)),
    [room, savedCallback]
  );
}
function useLostConnectionListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  useEffect5(
    () => room.events.lostConnection.subscribe(
      (event) => savedCallback.current(event)
    ),
    [room, savedCallback]
  );
}
function useEventListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  useEffect5(() => {
    const listener = (eventData) => {
      savedCallback.current(eventData);
    };
    return room.events.customEvent.subscribe(listener);
  }, [room, savedCallback]);
}
function useHistory() {
  return useRoom().history;
}
function useUndo() {
  return useHistory().undo;
}
function useRedo() {
  return useHistory().redo;
}
function useCanUndo() {
  const room = useRoom();
  const subscribe = room.events.history.subscribe;
  const canUndo = room.history.canUndo;
  return useSyncExternalStore3(subscribe, canUndo, canUndo);
}
function useCanRedo() {
  const room = useRoom();
  const subscribe = room.events.history.subscribe;
  const canRedo = room.history.canRedo;
  return useSyncExternalStore3(subscribe, canRedo, canRedo);
}
function useSelf(maybeSelector, isEqual) {
  const room = useRoom();
  const subscribe = room.events.self.subscribe;
  const getSnapshot = room.getSelf;
  const selector = maybeSelector ?? identity3;
  const wrappedSelector = useCallback3(
    (me) => me !== null ? selector(me) : null,
    [selector]
  );
  const getServerSnapshot = alwaysNull;
  return useSyncExternalStoreWithSelector(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    wrappedSelector,
    isEqual
  );
}
function useMyPresence() {
  const room = useRoom();
  const subscribe = room.events.myPresence.subscribe;
  const getSnapshot = room.getPresence;
  const presence = useSyncExternalStore3(subscribe, getSnapshot, getSnapshot);
  const setPresence = room.updatePresence;
  return [presence, setPresence];
}
function useUpdateMyPresence() {
  return useRoom().updatePresence;
}
function useOthers(selector, isEqual) {
  const room = useRoom();
  const subscribe = room.events.others.subscribe;
  const getSnapshot = room.getOthers;
  const getServerSnapshot = alwaysEmptyList;
  return useSyncExternalStoreWithSelector(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    selector ?? identity3,
    isEqual
  );
}
function useOthersMapped(itemSelector, itemIsEqual) {
  const wrappedSelector = useCallback3(
    (others) => others.map((other) => [other.connectionId, itemSelector(other)]),
    [itemSelector]
  );
  const wrappedIsEqual = useCallback3(
    (a, b) => {
      const eq = itemIsEqual ?? Object.is;
      return a.length === b.length && a.every((atuple, index) => {
        const btuple = b[index];
        return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);
      });
    },
    [itemIsEqual]
  );
  return useOthers(wrappedSelector, wrappedIsEqual);
}
function useOthersConnectionIds() {
  return useOthers(selectorFor_useOthersConnectionIds, shallow5);
}
var NOT_FOUND = Symbol();
function useOther(connectionId, selector, isEqual) {
  const wrappedSelector = useCallback3(
    (others) => {
      const other2 = others.find((other3) => other3.connectionId === connectionId);
      return other2 !== void 0 ? selector(other2) : NOT_FOUND;
    },
    [connectionId, selector]
  );
  const wrappedIsEqual = useCallback3(
    (prev, curr) => {
      if (prev === NOT_FOUND || curr === NOT_FOUND) {
        return prev === curr;
      }
      const eq = isEqual ?? Object.is;
      return eq(prev, curr);
    },
    [isEqual]
  );
  const other = useOthers(wrappedSelector, wrappedIsEqual);
  if (other === NOT_FOUND) {
    throw new Error(
      `No such other user with connection id ${connectionId} exists`
    );
  }
  return other;
}
function useMutableStorageRoot() {
  const room = useRoom();
  const subscribe = room.events.storageDidLoad.subscribeOnce;
  const getSnapshot = room.getStorageSnapshot;
  const getServerSnapshot = alwaysNull;
  return useSyncExternalStore3(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageRoot() {
  return [useMutableStorageRoot()];
}
function useStorage(selector, isEqual) {
  const room = useRoom();
  const rootOrNull = useMutableStorageRoot();
  const wrappedSelector = useCallback3(
    (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,
    [selector]
  );
  const subscribe = useCallback3(
    (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop3,
    [room, rootOrNull]
  );
  const getSnapshot = useCallback3(() => {
    if (rootOrNull === null) {
      return null;
    } else {
      const root = rootOrNull;
      const imm = root.toImmutable();
      return imm;
    }
  }, [rootOrNull]);
  const getServerSnapshot = alwaysNull;
  return useSyncExternalStoreWithSelector(
    subscribe,
    getSnapshot,
    getServerSnapshot,
    wrappedSelector,
    isEqual
  );
}
function useMutation(callback, deps) {
  const room = useRoom();
  return useMemo3(
    () => {
      return (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        room.batch(
          () => (
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            callback(
              makeMutationContext(room),
              ...args
            )
          )
        )
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [room, ...deps]
  );
}
function useThreads(options = {}) {
  const { scrollOnLoad = true } = options;
  const client = useClient();
  const room = useRoom();
  const { store, getOrCreateThreadsPollerForRoomId } = getRoomExtrasForClient(client);
  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);
  const poller = getOrCreateThreadsPollerForRoomId(room.id);
  useEffect5(
    () => void store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  useEffect5(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => poller.dec();
  }, [poller]);
  const result = useSignal(
    store.outputs.loadingRoomThreads.getOrCreate(queryKey).signal
  );
  useScrollToCommentOnLoadEffect(scrollOnLoad, result);
  return result;
}
function useCreateThread() {
  return useCreateRoomThread(useRoom().id);
}
function useCreateRoomThread(roomId) {
  const client = useClient();
  return useCallback3(
    (options) => {
      const body = options.body;
      const metadata = options.metadata ?? {};
      const attachments = options.attachments;
      const threadId = createThreadId();
      const commentId = createCommentId();
      const createdAt = /* @__PURE__ */ new Date();
      const newComment = {
        id: commentId,
        threadId,
        roomId,
        createdAt,
        type: "comment",
        userId: getCurrentUserId(client),
        body,
        reactions: [],
        attachments: attachments ?? []
      };
      const newThread = {
        id: threadId,
        type: "thread",
        createdAt,
        updatedAt: createdAt,
        roomId,
        metadata,
        comments: [newComment],
        resolved: false
      };
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "create-thread",
        thread: newThread,
        roomId
      });
      const attachmentIds = attachments?.map((attachment) => attachment.id);
      client[kInternal3].httpClient.createThread({
        roomId,
        threadId,
        commentId,
        body,
        metadata,
        attachmentIds
      }).then(
        (thread) => {
          store.createThread(optimisticId, thread);
        },
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "CREATE_THREAD_ERROR",
            roomId,
            threadId,
            commentId,
            body,
            metadata
          },
          err
        )
      );
      return newThread;
    },
    [client, roomId]
  );
}
function useDeleteThread() {
  return useDeleteRoomThread(useRoom().id);
}
function useDeleteRoomThread(roomId) {
  const client = useClient();
  return useCallback3(
    (threadId) => {
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const userId = getCurrentUserId(client);
      const existing = store.outputs.threads.get().get(threadId);
      if (existing?.comments?.[0]?.userId !== userId) {
        throw new Error("Only the thread creator can delete the thread");
      }
      const optimisticId = store.optimisticUpdates.add({
        type: "delete-thread",
        roomId,
        threadId,
        deletedAt: /* @__PURE__ */ new Date()
      });
      client[kInternal3].httpClient.deleteThread({ roomId, threadId }).then(
        () => {
          store.deleteThread(threadId, optimisticId);
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "DELETE_THREAD_ERROR", roomId, threadId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useEditThreadMetadata() {
  return useEditRoomThreadMetadata(useRoom().id);
}
function useEditRoomThreadMetadata(roomId) {
  const client = useClient();
  return useCallback3(
    (options) => {
      if (!options.metadata) {
        return;
      }
      const threadId = options.threadId;
      const metadata = options.metadata;
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "edit-thread-metadata",
        metadata,
        threadId,
        updatedAt
      });
      client[kInternal3].httpClient.editThreadMetadata({ roomId, threadId, metadata }).then(
        (metadata2) => (
          // Replace the optimistic update by the real thing
          store.patchThread(threadId, optimisticId, { metadata: metadata2 }, updatedAt)
        ),
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "EDIT_THREAD_METADATA_ERROR",
            roomId,
            threadId,
            metadata
          },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useCreateComment() {
  return useCreateRoomComment(useRoom().id);
}
function useCreateRoomComment(roomId) {
  const client = useClient();
  return useCallback3(
    ({ threadId, body, attachments }) => {
      const commentId = createCommentId();
      const createdAt = /* @__PURE__ */ new Date();
      const comment = {
        id: commentId,
        threadId,
        roomId,
        type: "comment",
        createdAt,
        userId: getCurrentUserId(client),
        body,
        reactions: [],
        attachments: attachments ?? []
      };
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "create-comment",
        comment
      });
      const attachmentIds = attachments?.map((attachment) => attachment.id);
      client[kInternal3].httpClient.createComment({ roomId, threadId, commentId, body, attachmentIds }).then(
        (newComment) => {
          store.createComment(newComment, optimisticId);
        },
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "CREATE_COMMENT_ERROR",
            roomId,
            threadId,
            commentId,
            body
          },
          err
        )
      );
      return comment;
    },
    [client, roomId]
  );
}
function useEditComment() {
  return useEditRoomComment(useRoom().id);
}
function useEditRoomComment(roomId) {
  const client = useClient();
  return useCallback3(
    ({ threadId, commentId, body, attachments }) => {
      const editedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const existing = store.outputs.threads.get().getEvenIfDeleted(threadId);
      if (existing === void 0) {
        console3.warn(
          `Internal unexpected behavior. Cannot edit comment in thread "${threadId}" because the thread does not exist in the cache.`
        );
        return;
      }
      const comment = existing.comments.find(
        (comment2) => comment2.id === commentId
      );
      if (comment === void 0 || comment.deletedAt !== void 0) {
        console3.warn(
          `Internal unexpected behavior. Cannot edit comment "${commentId}" in thread "${threadId}" because the comment does not exist in the cache.`
        );
        return;
      }
      const optimisticId = store.optimisticUpdates.add({
        type: "edit-comment",
        comment: {
          ...comment,
          editedAt,
          body,
          attachments: attachments ?? []
        }
      });
      const attachmentIds = attachments?.map((attachment) => attachment.id);
      client[kInternal3].httpClient.editComment({ roomId, threadId, commentId, body, attachmentIds }).then(
        (editedComment) => {
          store.editComment(threadId, optimisticId, editedComment);
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "EDIT_COMMENT_ERROR", roomId, threadId, commentId, body },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useDeleteComment() {
  return useDeleteRoomComment(useRoom().id);
}
function useDeleteRoomComment(roomId) {
  const client = useClient();
  return useCallback3(
    ({ threadId, commentId }) => {
      const deletedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "delete-comment",
        threadId,
        commentId,
        deletedAt,
        roomId
      });
      client[kInternal3].httpClient.deleteComment({ roomId, threadId, commentId }).then(
        () => {
          store.deleteComment(threadId, optimisticId, commentId, deletedAt);
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "DELETE_COMMENT_ERROR", roomId, threadId, commentId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useAddReaction() {
  return useAddRoomCommentReaction(useRoom().id);
}
function useAddRoomCommentReaction(roomId) {
  const client = useClient();
  return useCallback3(
    ({ threadId, commentId, emoji }) => {
      const createdAt = /* @__PURE__ */ new Date();
      const userId = getCurrentUserId(client);
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "add-reaction",
        threadId,
        commentId,
        reaction: {
          emoji,
          userId,
          createdAt
        }
      });
      client[kInternal3].httpClient.addReaction({ roomId, threadId, commentId, emoji }).then(
        (addedReaction) => {
          store.addReaction(
            threadId,
            optimisticId,
            commentId,
            addedReaction,
            createdAt
          );
        },
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "ADD_REACTION_ERROR",
            roomId,
            threadId,
            commentId,
            emoji
          },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useRemoveReaction() {
  return useRemoveRoomCommentReaction(useRoom().id);
}
function useRemoveRoomCommentReaction(roomId) {
  const client = useClient();
  return useCallback3(
    ({ threadId, commentId, emoji }) => {
      const userId = getCurrentUserId(client);
      const removedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "remove-reaction",
        threadId,
        commentId,
        emoji,
        userId,
        removedAt
      });
      client[kInternal3].httpClient.removeReaction({ roomId, threadId, commentId, emoji }).then(
        () => {
          store.removeReaction(
            threadId,
            optimisticId,
            commentId,
            emoji,
            userId,
            removedAt
          );
        },
        (err) => onMutationFailure(
          optimisticId,
          {
            type: "REMOVE_REACTION_ERROR",
            roomId,
            threadId,
            commentId,
            emoji
          },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useMarkThreadAsRead() {
  return useMarkRoomThreadAsRead(useRoom().id);
}
function useMarkRoomThreadAsRead(roomId) {
  const client = useClient();
  return useCallback3(
    (threadId) => {
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const inboxNotification = Object.values(
        store.outputs.notifications.get().notificationsById
      ).find(
        (inboxNotification2) => inboxNotification2.kind === "thread" && inboxNotification2.threadId === threadId
      );
      if (!inboxNotification) return;
      const now = /* @__PURE__ */ new Date();
      const optimisticId = store.optimisticUpdates.add({
        type: "mark-inbox-notification-as-read",
        inboxNotificationId: inboxNotification.id,
        readAt: now
      });
      client[kInternal3].httpClient.markRoomInboxNotificationAsRead({
        roomId,
        inboxNotificationId: inboxNotification.id
      }).then(
        () => {
          store.markInboxNotificationRead(
            inboxNotification.id,
            now,
            optimisticId
          );
        },
        (err) => {
          onMutationFailure(
            optimisticId,
            {
              type: "MARK_INBOX_NOTIFICATION_AS_READ_ERROR",
              roomId,
              inboxNotificationId: inboxNotification.id
            },
            err
          );
          return;
        }
      );
    },
    [client, roomId]
  );
}
function useMarkThreadAsResolved() {
  return useMarkRoomThreadAsResolved(useRoom().id);
}
function useMarkRoomThreadAsResolved(roomId) {
  const client = useClient();
  return useCallback3(
    (threadId) => {
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "mark-thread-as-resolved",
        threadId,
        updatedAt
      });
      client[kInternal3].httpClient.markThreadAsResolved({ roomId, threadId }).then(
        () => {
          store.patchThread(
            threadId,
            optimisticId,
            { resolved: true },
            updatedAt
          );
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "MARK_THREAD_AS_RESOLVED_ERROR", roomId, threadId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useMarkThreadAsUnresolved() {
  return useMarkRoomThreadAsUnresolved(useRoom().id);
}
function useMarkRoomThreadAsUnresolved(roomId) {
  const client = useClient();
  return useCallback3(
    (threadId) => {
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "mark-thread-as-unresolved",
        threadId,
        updatedAt
      });
      client[kInternal3].httpClient.markThreadAsUnresolved({ roomId, threadId }).then(
        () => {
          store.patchThread(
            threadId,
            optimisticId,
            { resolved: false },
            updatedAt
          );
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "MARK_THREAD_AS_UNRESOLVED_ERROR", roomId, threadId },
          err
        )
      );
    },
    [client, roomId]
  );
}
function useThreadSubscription(threadId) {
  const client = useClient();
  const { store } = getRoomExtrasForClient(client);
  const signal = store.outputs.threadifications;
  const selector = useCallback3(
    (state) => {
      const notification = state.sortedNotifications.find(
        (inboxNotification) => inboxNotification.kind === "thread" && inboxNotification.threadId === threadId
      );
      const thread = state.threadsDB.get(threadId);
      if (notification === void 0 || thread === void 0) {
        return { status: "not-subscribed" };
      }
      return {
        status: "subscribed",
        unreadSince: notification.readAt
      };
    },
    [threadId]
  );
  return useSignal(signal, selector, shallow5);
}
function useRoomNotificationSettings() {
  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();
  const client = useClient();
  const room = useRoom();
  const { store, getOrCreateNotificationsSettingsPollerForRoomId } = getRoomExtrasForClient(client);
  const poller = getOrCreateNotificationsSettingsPollerForRoomId(room.id);
  useEffect5(
    () => void store.outputs.settingsByRoomId.getOrCreate(room.id).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  useEffect5(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => {
      poller.dec();
    };
  }, [poller]);
  const settings = useSignal(
    store.outputs.settingsByRoomId.getOrCreate(room.id).signal
  );
  return useMemo3(() => {
    return [settings, updateRoomNotificationSettings];
  }, [settings, updateRoomNotificationSettings]);
}
function useRoomNotificationSettingsSuspense() {
  ensureNotServerSide();
  const client = useClient();
  const store = getRoomExtrasForClient(client).store;
  const room = useRoom();
  use(store.outputs.settingsByRoomId.getOrCreate(room.id).waitUntilLoaded());
  const [settings, updateRoomNotificationSettings] = useRoomNotificationSettings();
  assert2(!settings.error, "Did not expect error");
  assert2(!settings.isLoading, "Did not expect loading");
  return useMemo3(() => {
    return [settings, updateRoomNotificationSettings];
  }, [settings, updateRoomNotificationSettings]);
}
function useHistoryVersionData(versionId) {
  const [state, setState] = useState2({
    isLoading: true
  });
  const room = useRoom();
  useEffect5(() => {
    setState({ isLoading: true });
    const load = async () => {
      try {
        const response = await room[kInternal3].getTextVersion(versionId);
        const buffer = await response.arrayBuffer();
        const data = new Uint8Array(buffer);
        setState({
          isLoading: false,
          data
        });
      } catch (error) {
        setState({
          isLoading: false,
          error: error instanceof Error ? error : new Error(
            "An unknown error occurred while loading this version"
          )
        });
      }
    };
    void load();
  }, [room, versionId]);
  return state;
}
function useHistoryVersions() {
  const client = useClient();
  const room = useRoom();
  const { store, getOrCreateVersionsPollerForRoomId } = getRoomExtrasForClient(client);
  const poller = getOrCreateVersionsPollerForRoomId(room.id);
  useEffect5(() => {
    poller.inc();
    poller.pollNowIfStale();
    return () => poller.dec();
  }, [poller]);
  useEffect5(
    () => void store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded()
    // NOTE: Deliberately *not* using a dependency array here!
    //
    // It is important to call waitUntil on *every* render.
    // This is harmless though, on most renders, except:
    // 1. The very first render, in which case we'll want to trigger the initial page fetch.
    // 2. All other subsequent renders now "just" return the same promise (a quick operation).
    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very
    //    *next* render after that, a *new* fetch/promise will get created.
  );
  return useSignal(store.outputs.versionsByRoomId.getOrCreate(room.id).signal);
}
function useHistoryVersionsSuspense() {
  ensureNotServerSide();
  const client = useClient();
  const room = useRoom();
  const store = getRoomExtrasForClient(client).store;
  use(store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded());
  const result = useHistoryVersions();
  assert2(!result.error, "Did not expect error");
  assert2(!result.isLoading, "Did not expect loading");
  return result;
}
function useUpdateRoomNotificationSettings() {
  const client = useClient();
  const room = useRoom();
  return useCallback3(
    (settings) => {
      const { store, onMutationFailure } = getRoomExtrasForClient(client);
      const optimisticId = store.optimisticUpdates.add({
        type: "update-notification-settings",
        roomId: room.id,
        settings
      });
      room.updateNotificationSettings(settings).then(
        (settings2) => {
          store.updateRoomNotificationSettings(room.id, optimisticId, settings2);
        },
        (err) => onMutationFailure(
          optimisticId,
          { type: "UPDATE_NOTIFICATION_SETTINGS_ERROR", roomId: room.id },
          err
        )
      );
    },
    [client, room]
  );
}
function useSuspendUntilPresenceReady() {
  ensureNotServerSide();
  const room = useRoom();
  use(room.waitUntilPresenceReady());
}
function useSelfSuspense(selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useSelf(
    selector,
    isEqual
  );
}
function useOthersSuspense(selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useOthers(
    selector,
    isEqual
  );
}
function useOthersConnectionIdsSuspense() {
  useSuspendUntilPresenceReady();
  return useOthersConnectionIds();
}
function useOthersMappedSuspense(itemSelector, itemIsEqual) {
  useSuspendUntilPresenceReady();
  return useOthersMapped(itemSelector, itemIsEqual);
}
function useOtherSuspense(connectionId, selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useOther(connectionId, selector, isEqual);
}
function useSuspendUntilStorageReady() {
  ensureNotServerSide();
  const room = useRoom();
  use(room.waitUntilStorageReady());
}
function useStorageSuspense(selector, isEqual) {
  useSuspendUntilStorageReady();
  return useStorage(
    selector,
    isEqual
  );
}
function useStorageStatusSuspense(options) {
  useSuspendUntilStorageReady();
  return useStorageStatus(options);
}
function useThreadsSuspense(options = {}) {
  ensureNotServerSide();
  const client = useClient();
  const room = useRoom();
  const { store } = getRoomExtrasForClient(client);
  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);
  use(store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded());
  const result = useThreads(options);
  assert2(!result.error, "Did not expect error");
  assert2(!result.isLoading, "Did not expect loading");
  return result;
}
function selectorFor_useAttachmentUrl(state) {
  if (state === void 0 || state?.isLoading) {
    return state ?? { isLoading: true };
  }
  if (state.error) {
    return state;
  }
  assert2(state.data !== void 0, "Unexpected missing attachment URL");
  return {
    isLoading: false,
    url: state.data
  };
}
function useAttachmentUrl(attachmentId) {
  const room = useRoom();
  return useRoomAttachmentUrl(attachmentId, room.id);
}
function useRoomAttachmentUrl(attachmentId, roomId) {
  const client = useClient();
  const store = client[kInternal3].httpClient.getOrCreateAttachmentUrlsStore(roomId);
  const getAttachmentUrlState = useCallback3(
    () => store.getItemState(attachmentId),
    [store, attachmentId]
  );
  useEffect5(() => {
    void store.enqueue(attachmentId);
  }, [store, attachmentId]);
  return useSyncExternalStoreWithSelector(
    store.subscribe,
    getAttachmentUrlState,
    getAttachmentUrlState,
    selectorFor_useAttachmentUrl,
    shallow5
  );
}
function useAttachmentUrlSuspense(attachmentId) {
  const room = useRoom();
  const { attachmentUrlsStore } = room[kInternal3];
  const getAttachmentUrlState = useCallback3(
    () => attachmentUrlsStore.getItemState(attachmentId),
    [attachmentUrlsStore, attachmentId]
  );
  const attachmentUrlState = getAttachmentUrlState();
  if (!attachmentUrlState || attachmentUrlState.isLoading) {
    throw attachmentUrlsStore.enqueue(attachmentId);
  }
  if (attachmentUrlState.error) {
    throw attachmentUrlState.error;
  }
  const state = useSyncExternalStore3(
    attachmentUrlsStore.subscribe,
    getAttachmentUrlState,
    getAttachmentUrlState
  );
  assert2(state !== void 0, "Unexpected missing state");
  assert2(!state.isLoading, "Unexpected loading state");
  assert2(!state.error, "Unexpected error state");
  return {
    isLoading: false,
    url: state.data,
    error: void 0
  };
}
var NO_PERMISSIONS = /* @__PURE__ */ new Set();
function useRoomPermissions(roomId) {
  const client = useClient();
  const store = getRoomExtrasForClient(client).store;
  return useSignal(
    store.permissionHints.signal,
    (hints) => hints.get(roomId) ?? NO_PERMISSIONS
  );
}
function createRoomContext(client) {
  return getOrCreateRoomContextBundle(client);
}
var _RoomProvider = RoomProvider;
var _useBroadcastEvent = useBroadcastEvent;
var _useOthersListener = useOthersListener;
var _useRoom = useRoom;
var _useIsInsideRoom = useIsInsideRoom;
var _useAddReaction = useAddReaction;
var _useMutation = useMutation;
var _useCreateThread = useCreateThread;
var _useDeleteThread = useDeleteThread;
var _useEditThreadMetadata = useEditThreadMetadata;
var _useEventListener = useEventListener;
var _useMyPresence = useMyPresence;
var _useOthersMapped = useOthersMapped;
var _useOthersMappedSuspense = useOthersMappedSuspense;
var _useThreads = useThreads;
var _useThreadsSuspense = useThreadsSuspense;
var _useRoomNotificationSettings = useRoomNotificationSettings;
var _useRoomNotificationSettingsSuspense = useRoomNotificationSettingsSuspense;
var _useHistoryVersions = useHistoryVersions;
var _useHistoryVersionsSuspense = useHistoryVersionsSuspense;
var _useOther = useOther;
function _useOthers(...args) {
  return useOthers(...args);
}
var _useOtherSuspense = useOtherSuspense;
function _useOthersSuspense(...args) {
  return useOthersSuspense(...args);
}
var _useStorage = useStorage;
var _useStorageSuspense = useStorageSuspense;
function _useSelf(...args) {
  return useSelf(...args);
}
function _useSelfSuspense(...args) {
  return useSelfSuspense(...args);
}
var _useStorageRoot = useStorageRoot;
var _useUpdateMyPresence = useUpdateMyPresence;

export {
  RoomContext,
  useRoomOrNull,
  useSyncExternalStoreWithSelector,
  useSignal,
  ClientContext,
  getUmbrellaStoreForClient,
  useClientOrNull,
  useClient,
  LiveblocksProvider,
  createLiveblocksContext,
  useInboxNotifications,
  useInboxNotificationsSuspense,
  useMarkAllInboxNotificationsAsRead,
  useMarkInboxNotificationAsRead,
  useDeleteAllInboxNotifications,
  useDeleteInboxNotification,
  useUnreadInboxNotificationsCount,
  useUnreadInboxNotificationsCountSuspense,
  useRoomInfo,
  useRoomInfoSuspense,
  _useInboxNotificationThread,
  _useUser,
  _useUserSuspense,
  _useUserThreads_experimental,
  _useUserThreadsSuspense_experimental,
  useSyncStatus,
  useErrorListener,
  useStatus,
  useReportTextEditor,
  useYjsProvider,
  useCreateTextMention,
  useDeleteTextMention,
  useResolveMentionSuggestions,
  useMentionSuggestionsCache,
  useStorageStatus,
  useBatch,
  useLostConnectionListener,
  useHistory,
  useUndo,
  useRedo,
  useCanUndo,
  useCanRedo,
  useOthersConnectionIds,
  useCreateRoomThread,
  useDeleteRoomThread,
  useEditRoomThreadMetadata,
  useCreateComment,
  useCreateRoomComment,
  useEditComment,
  useEditRoomComment,
  useDeleteComment,
  useDeleteRoomComment,
  useAddRoomCommentReaction,
  useRemoveReaction,
  useRemoveRoomCommentReaction,
  useMarkThreadAsRead,
  useMarkRoomThreadAsRead,
  useMarkThreadAsResolved,
  useMarkRoomThreadAsResolved,
  useMarkThreadAsUnresolved,
  useMarkRoomThreadAsUnresolved,
  useThreadSubscription,
  useHistoryVersionData,
  useUpdateRoomNotificationSettings,
  useOthersConnectionIdsSuspense,
  useStorageStatusSuspense,
  useAttachmentUrl,
  useRoomAttachmentUrl,
  useAttachmentUrlSuspense,
  useRoomPermissions,
  createRoomContext,
  _RoomProvider,
  _useBroadcastEvent,
  _useOthersListener,
  _useRoom,
  _useIsInsideRoom,
  _useAddReaction,
  _useMutation,
  _useCreateThread,
  _useDeleteThread,
  _useEditThreadMetadata,
  _useEventListener,
  _useMyPresence,
  _useOthersMapped,
  _useOthersMappedSuspense,
  _useThreads,
  _useThreadsSuspense,
  _useRoomNotificationSettings,
  _useRoomNotificationSettingsSuspense,
  _useHistoryVersions,
  _useHistoryVersionsSuspense,
  _useOther,
  _useOthers,
  _useOtherSuspense,
  _useOthersSuspense,
  _useStorage,
  _useStorageSuspense,
  _useSelf,
  _useSelfSuspense,
  _useStorageRoot,
  _useUpdateMyPresence
};
//# sourceMappingURL=chunk-4KNGHD4I.mjs.map