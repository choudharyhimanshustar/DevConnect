'use strict';

var jsxRuntime = require('react/jsx-runtime');
var LexicalComposerContext = require('@lexical/react/LexicalComposerContext');
var richText = require('@lexical/rich-text');
var selection = require('@lexical/selection');
var utils = require('@lexical/utils');
var _private = require('@liveblocks/react-ui/_private');
var SelectPrimitive = require('@radix-ui/react-select');
var TogglePrimitive = require('@radix-ui/react-toggle');
var lexical = require('lexical');
var react = require('react');
var classnames = require('../classnames.js');
var floatingComposer = require('../comments/floating-composer.js');
var isBlockNodeActive = require('../is-block-node-active.js');
var isCommandRegistered = require('../is-command-registered.js');
var isTextFormatActive = require('../is-text-format-active.js');
var shared = require('./shared.js');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var SelectPrimitive__namespace = /*#__PURE__*/_interopNamespaceDefault(SelectPrimitive);
var TogglePrimitive__namespace = /*#__PURE__*/_interopNamespaceDefault(TogglePrimitive);

const BLOCK_SELECT_SIDE_OFFSET = 10;
const FLOATING_ELEMENT_COLLISION_PADDING = 10;
function applyToolbarSlot(slot, props) {
  if (typeof slot === "function") {
    const Component = slot;
    return /* @__PURE__ */ jsxRuntime.jsx(Component, {
      ...props
    });
  }
  return slot;
}
const ToolbarButton = react.forwardRef(
  ({ icon, children, name, shortcut, onKeyDown, ...props }, forwardedRef) => {
    const floatingToolbarContext = react.useContext(shared.FloatingToolbarContext);
    const closeFloatingToolbar = floatingToolbarContext?.close;
    const handleKeyDown = react.useCallback(
      (event) => {
        onKeyDown?.(event);
        if (!event.isDefaultPrevented() && closeFloatingToolbar && event.key === "Escape") {
          closeFloatingToolbar();
          event.preventDefault();
          event.stopPropagation();
        }
      },
      [onKeyDown, closeFloatingToolbar]
    );
    return /* @__PURE__ */ jsxRuntime.jsx(_private.ShortcutTooltip, {
      content: name,
      shortcut,
      children: /* @__PURE__ */ jsxRuntime.jsx(_private.Button, {
        type: "button",
        variant: "toolbar",
        ref: forwardedRef,
        icon,
        "aria-label": !children ? name : void 0,
        ...props,
        onKeyDown: handleKeyDown,
        children: !children && !icon ? name : children
      })
    });
  }
);
const ToolbarToggle = react.forwardRef(
  ({ active, ...props }, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntime.jsx(TogglePrimitive__namespace.Root, {
      asChild: true,
      pressed: active,
      children: /* @__PURE__ */ jsxRuntime.jsx(ToolbarButton, {
        ref: forwardedRef,
        ...props
      })
    });
  }
);
const ToolbarSeparator = react.forwardRef(
  ({ className, ...props }, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntime.jsx("div", {
      ref: forwardedRef,
      role: "separator",
      "aria-orientation": "vertical",
      className: classnames.classNames("lb-lexical-toolbar-separator", className),
      ...props
    });
  }
);
function ToolbarSectionHistory() {
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const [canUndo, setCanUndo] = react.useState(false);
  const [canRedo, setCanRedo] = react.useState(false);
  react.useEffect(() => {
    const unregister = utils.mergeRegister(
      editor.registerCommand(
        lexical.CAN_UNDO_COMMAND,
        (payload) => {
          setCanUndo(payload);
          return false;
        },
        lexical.COMMAND_PRIORITY_CRITICAL
      ),
      editor.registerCommand(
        lexical.CAN_REDO_COMMAND,
        (payload) => {
          setCanRedo(payload);
          return false;
        },
        lexical.COMMAND_PRIORITY_CRITICAL
      )
    );
    return unregister;
  }, [editor]);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(ToolbarButton, {
        name: "Undo",
        icon: /* @__PURE__ */ jsxRuntime.jsx(_private.UndoIcon, {}),
        shortcut: "Mod-Z",
        onClick: () => editor.dispatchCommand(lexical.UNDO_COMMAND, void 0),
        disabled: !canUndo
      }),
      /* @__PURE__ */ jsxRuntime.jsx(ToolbarButton, {
        name: "Redo",
        icon: /* @__PURE__ */ jsxRuntime.jsx(_private.RedoIcon, {}),
        shortcut: "Mod-Shift-Z",
        onClick: () => editor.dispatchCommand(lexical.REDO_COMMAND, void 0),
        disabled: !canRedo
      })
    ]
  });
}
function ToolbarSectionInline() {
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const supportsTextFormat = isCommandRegistered.useIsCommandRegistered(lexical.FORMAT_TEXT_COMMAND);
  return supportsTextFormat ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(ToolbarToggle, {
        name: "Bold",
        icon: /* @__PURE__ */ jsxRuntime.jsx(_private.BoldIcon, {}),
        shortcut: "Mod-B",
        onClick: () => editor.dispatchCommand(lexical.FORMAT_TEXT_COMMAND, "bold"),
        active: isTextFormatActive.isTextFormatActive(editor, "bold")
      }),
      /* @__PURE__ */ jsxRuntime.jsx(ToolbarToggle, {
        name: "Italic",
        icon: /* @__PURE__ */ jsxRuntime.jsx(_private.ItalicIcon, {}),
        shortcut: "Mod-I",
        onClick: () => editor.dispatchCommand(lexical.FORMAT_TEXT_COMMAND, "italic"),
        active: isTextFormatActive.isTextFormatActive(editor, "italic")
      }),
      /* @__PURE__ */ jsxRuntime.jsx(ToolbarToggle, {
        name: "Underline",
        icon: /* @__PURE__ */ jsxRuntime.jsx(_private.UnderlineIcon, {}),
        shortcut: "Mod-U",
        onClick: () => editor.dispatchCommand(lexical.FORMAT_TEXT_COMMAND, "underline"),
        active: isTextFormatActive.isTextFormatActive(editor, "underline")
      }),
      /* @__PURE__ */ jsxRuntime.jsx(ToolbarToggle, {
        name: "Strikethrough",
        icon: /* @__PURE__ */ jsxRuntime.jsx(_private.StrikethroughIcon, {}),
        onClick: () => editor.dispatchCommand(lexical.FORMAT_TEXT_COMMAND, "strikethrough"),
        active: isTextFormatActive.isTextFormatActive(editor, "strikethrough")
      }),
      /* @__PURE__ */ jsxRuntime.jsx(ToolbarToggle, {
        name: "Inline code",
        icon: /* @__PURE__ */ jsxRuntime.jsx(_private.CodeIcon, {}),
        onClick: () => editor.dispatchCommand(lexical.FORMAT_TEXT_COMMAND, "code"),
        active: isTextFormatActive.isTextFormatActive(editor, "code")
      })
    ]
  }) : null;
}
function ToolbarSectionCollaboration() {
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const supportsThread = isCommandRegistered.useIsCommandRegistered(floatingComposer.OPEN_FLOATING_COMPOSER_COMMAND);
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: supportsThread ? /* @__PURE__ */ jsxRuntime.jsx(ToolbarButton, {
      name: "Add a comment",
      icon: /* @__PURE__ */ jsxRuntime.jsx(_private.CommentIcon, {}),
      onClick: () => editor.dispatchCommand(floatingComposer.OPEN_FLOATING_COMPOSER_COMMAND, void 0),
      children: "Comment"
    }) : null
  });
}
function DefaultToolbarContent() {
  const supportsTextFormat = isCommandRegistered.useIsCommandRegistered(lexical.FORMAT_TEXT_COMMAND);
  const supportsThread = isCommandRegistered.useIsCommandRegistered(floatingComposer.OPEN_FLOATING_COMPOSER_COMMAND);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(ToolbarSectionHistory, {}),
      supportsTextFormat ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(ToolbarSeparator, {}),
          /* @__PURE__ */ jsxRuntime.jsx(ToolbarBlockSelector, {}),
          /* @__PURE__ */ jsxRuntime.jsx(ToolbarSectionInline, {})
        ]
      }) : null,
      supportsThread ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(ToolbarSeparator, {}),
          /* @__PURE__ */ jsxRuntime.jsx(ToolbarSectionCollaboration, {})
        ]
      }) : null
    ]
  });
}
const INITIAL_COMMANDS_REGISTERED_COMMAND = lexical.createCommand(
  "INITIAL_COMMANDS_REGISTERED_COMMAND"
);
function useRerender() {
  const [, setRerender] = react.useState(false);
  return react.useCallback(() => {
    setRerender((toggle) => !toggle);
  }, [setRerender]);
}
function createDefaultBlockSelectorItems() {
  const items = [
    {
      name: "Text",
      icon: /* @__PURE__ */ jsxRuntime.jsx(_private.TextIcon, {}),
      isActive: "default",
      setActive: () => selection.$setBlocksType(lexical.$getSelection(), () => lexical.$createParagraphNode())
    },
    {
      name: "Heading 1",
      icon: /* @__PURE__ */ jsxRuntime.jsx(_private.H1Icon, {}),
      isActive: (editor) => {
        return isBlockNodeActive.isBlockNodeActive(
          editor,
          (node) => richText.$isHeadingNode(node) ? node.getTag() === "h1" : false
        );
      },
      setActive: () => selection.$setBlocksType(lexical.$getSelection(), () => richText.$createHeadingNode("h1"))
    },
    {
      name: "Heading 2",
      icon: /* @__PURE__ */ jsxRuntime.jsx(_private.H2Icon, {}),
      isActive: (editor) => isBlockNodeActive.isBlockNodeActive(
        editor,
        (node) => richText.$isHeadingNode(node) ? node.getTag() === "h2" : false
      ),
      setActive: () => selection.$setBlocksType(lexical.$getSelection(), () => richText.$createHeadingNode("h2"))
    },
    {
      name: "Heading 3",
      icon: /* @__PURE__ */ jsxRuntime.jsx(_private.H3Icon, {}),
      isActive: (editor) => isBlockNodeActive.isBlockNodeActive(
        editor,
        (node) => richText.$isHeadingNode(node) ? node.getTag() === "h3" : false
      ),
      setActive: () => selection.$setBlocksType(lexical.$getSelection(), () => richText.$createHeadingNode("h3"))
    },
    {
      name: "Blockquote",
      icon: /* @__PURE__ */ jsxRuntime.jsx(_private.BlockquoteIcon, {}),
      isActive: (editor) => isBlockNodeActive.isBlockNodeActive(editor, (node) => node.getType() === "quote"),
      setActive: () => selection.$setBlocksType(lexical.$getSelection(), () => richText.$createQuoteNode())
    }
  ];
  return items.filter(Boolean);
}
const ToolbarBlockSelector = react.forwardRef(({ items, onKeyDown, ...props }, forwardedRef) => {
  const floatingToolbarContext = react.useContext(shared.FloatingToolbarContext);
  const closeFloatingToolbar = floatingToolbarContext?.close;
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const resolvedItems = react.useMemo(() => {
    if (Array.isArray(items)) {
      return items;
    }
    const defaultItems = createDefaultBlockSelectorItems();
    return items ? items(defaultItems) : defaultItems;
  }, [items]);
  let defaultItem;
  let activeItem = resolvedItems.find((item) => {
    if (item.isActive === "default") {
      defaultItem = item;
      return false;
    }
    return item.isActive(editor);
  });
  if (!activeItem) {
    activeItem = defaultItem;
  }
  const handleItemChange = (name) => {
    const item = resolvedItems.find((item2) => item2.name === name);
    if (item) {
      editor.update(() => item.setActive(editor));
      floatingToolbarContext?.close();
    }
  };
  const handleKeyDown = react.useCallback(
    (event) => {
      onKeyDown?.(event);
      if (!event.isDefaultPrevented() && closeFloatingToolbar && event.key === "Escape") {
        closeFloatingToolbar();
        event.preventDefault();
        event.stopPropagation();
      }
    },
    [onKeyDown, closeFloatingToolbar]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(SelectPrimitive__namespace.Root, {
    value: activeItem?.name,
    onValueChange: handleItemChange,
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(_private.ShortcutTooltip, {
        content: "Turn into\u2026",
        children: /* @__PURE__ */ jsxRuntime.jsx(SelectPrimitive__namespace.Trigger, {
          asChild: true,
          ...props,
          ref: forwardedRef,
          onKeyDown: handleKeyDown,
          disabled: resolvedItems.length === 0,
          children: /* @__PURE__ */ jsxRuntime.jsx(_private.SelectButton, {
            variant: "toolbar",
            children: activeItem?.name ?? "Turn into\u2026"
          })
        })
      }),
      /* @__PURE__ */ jsxRuntime.jsx(SelectPrimitive__namespace.Portal, {
        children: /* @__PURE__ */ jsxRuntime.jsx(shared.FloatingToolbarExternal, {
          children: /* @__PURE__ */ jsxRuntime.jsx(SelectPrimitive__namespace.Content, {
            position: "popper",
            sideOffset: BLOCK_SELECT_SIDE_OFFSET,
            collisionPadding: FLOATING_ELEMENT_COLLISION_PADDING,
            className: "lb-root lb-portal lb-elevation lb-dropdown lb-select-dropdown lb-lexical-block-selector-dropdown",
            children: resolvedItems.map((item) => /* @__PURE__ */ jsxRuntime.jsxs(SelectPrimitive__namespace.Item, {
              value: item.name,
              className: "lb-dropdown-item",
              "data-name": item.name,
              children: [
                item.icon ? /* @__PURE__ */ jsxRuntime.jsx("span", {
                  className: "lb-dropdown-item-icon lb-icon-container",
                  children: item.icon
                }) : null,
                /* @__PURE__ */ jsxRuntime.jsx("span", {
                  className: "lb-dropdown-item-label",
                  children: item.label ?? item.name
                }),
                item.name === activeItem?.name ? /* @__PURE__ */ jsxRuntime.jsx("span", {
                  className: "lb-dropdown-item-accessory lb-icon-container",
                  children: /* @__PURE__ */ jsxRuntime.jsx(_private.CheckIcon, {})
                }) : null
              ]
            }, item.name))
          })
        })
      })
    ]
  });
});
const Toolbar = Object.assign(
  react.forwardRef(
    ({ before, after, children = DefaultToolbarContent, className, ...props }, forwardedRef) => {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const [commandsRegistered, setCommandsRegistered] = react.useState(false);
      const rerender = useRerender();
      const slotProps = { editor };
      react.useEffect(() => {
        if (commandsRegistered) {
          return;
        }
        const unregister = editor.registerCommand(
          INITIAL_COMMANDS_REGISTERED_COMMAND,
          () => {
            setCommandsRegistered(true);
            return true;
          },
          lexical.COMMAND_PRIORITY_LOW
        );
        editor.dispatchCommand(INITIAL_COMMANDS_REGISTERED_COMMAND, void 0);
        return unregister;
      }, [editor, commandsRegistered]);
      react.useEffect(() => {
        const unregister = editor.registerUpdateListener(({ tags }) => {
          return editor.getEditorState().read(() => {
            if (tags.has("collaboration"))
              return;
            rerender();
          });
        });
        return unregister;
      }, [editor, rerender]);
      return /* @__PURE__ */ jsxRuntime.jsx(_private.TooltipProvider, {
        children: /* @__PURE__ */ jsxRuntime.jsxs("div", {
          ref: forwardedRef,
          role: "toolbar",
          "aria-label": "Toolbar",
          "aria-orientation": "horizontal",
          className: classnames.classNames("lb-root lb-lexical-toolbar", className),
          ...props,
          children: [
            applyToolbarSlot(before, slotProps),
            applyToolbarSlot(children, slotProps),
            applyToolbarSlot(after, slotProps)
          ]
        })
      });
    }
  ),
  {
    Button: ToolbarButton,
    Toggle: ToolbarToggle,
    BlockSelector: ToolbarBlockSelector,
    Separator: ToolbarSeparator,
    SectionHistory: ToolbarSectionHistory,
    SectionInline: ToolbarSectionInline,
    SectionCollaboration: ToolbarSectionCollaboration
  }
);

exports.BLOCK_SELECT_SIDE_OFFSET = BLOCK_SELECT_SIDE_OFFSET;
exports.FLOATING_ELEMENT_COLLISION_PADDING = FLOATING_ELEMENT_COLLISION_PADDING;
exports.Toolbar = Toolbar;
exports.applyToolbarSlot = applyToolbarSlot;
//# sourceMappingURL=toolbar.js.map
