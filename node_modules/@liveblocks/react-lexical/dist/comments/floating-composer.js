'use strict';

var jsxRuntime = require('react/jsx-runtime');
var reactDom = require('@floating-ui/react-dom');
var LexicalComposerContext = require('@lexical/react/LexicalComposerContext');
var react$1 = require('@liveblocks/react');
var _private = require('@liveblocks/react/_private');
var reactUi = require('@liveblocks/react-ui');
var lexical = require('lexical');
var react = require('react');
var reactDom$1 = require('react-dom');
var createDomRange = require('../create-dom-range.js');
var createRectsFromDomRange = require('../create-rects-from-dom-range.js');
var wrapSelectionInThreadMarkNode = require('./wrap-selection-in-thread-mark-node.js');

const OPEN_FLOATING_COMPOSER_COMMAND = lexical.createCommand("OPEN_FLOATING_COMPOSER_COMMAND");
const FloatingComposer = react.forwardRef(function FloatingComposer2(props, forwardedRef) {
  const [range, setRange] = react.useState(null);
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  react.useEffect(() => {
    return editor.registerCommand(
      OPEN_FLOATING_COMPOSER_COMMAND,
      () => {
        const selection = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection))
          return false;
        if (selection.isCollapsed())
          return false;
        const { anchor, focus } = selection;
        const range2 = createDomRange.createDOMRange(
          editor,
          anchor.getNode(),
          anchor.offset,
          focus.getNode(),
          focus.offset
        );
        setRange(range2);
        return true;
      },
      lexical.COMMAND_PRIORITY_EDITOR
    );
  }, [editor]);
  if (range === null)
    return null;
  return /* @__PURE__ */ jsxRuntime.jsx(FloatingComposerImpl, {
    ref: forwardedRef,
    ...props,
    range,
    onRangeChange: setRange
  });
});
const FloatingComposerImpl = react.forwardRef(function FloatingComposer3(props, forwardedRef) {
  const {
    range,
    onRangeChange,
    onKeyDown,
    onComposerSubmit,
    ...composerProps
  } = props;
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const createThread = react$1.useCreateThread();
  const $onStateRead = react.useCallback(() => {
    const selection = lexical.$getSelection();
    if (!lexical.$isRangeSelection(selection) || selection.isCollapsed()) {
      return null;
    }
    const { anchor, focus } = selection;
    const range2 = createDomRange.createDOMRange(
      editor,
      anchor.getNode(),
      anchor.offset,
      focus.getNode(),
      focus.offset
    );
    return range2;
  }, [editor]);
  react.useEffect(() => {
    return editor.registerUpdateListener(({ editorState: state, tags }) => {
      if (!tags.has("collaboration")) {
        onRangeChange(null);
        return;
      }
      const range2 = state.read(() => $onStateRead());
      onRangeChange(range2);
    });
  }, [editor, range, onRangeChange, $onStateRead]);
  const onThreadCreate = react.useCallback(
    (threadId) => {
      editor.update(() => {
        const selection = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection))
          return;
        if (selection.isCollapsed())
          return;
        const isBackward = selection.isBackward();
        wrapSelectionInThreadMarkNode(selection, isBackward, threadId);
        lexical.$setSelection(null);
      });
    },
    [editor]
  );
  const handleComposerSubmit = react.useCallback(
    (comment, event) => {
      onComposerSubmit?.(comment, event);
      if (event.defaultPrevented)
        return;
      event.preventDefault();
      const thread = createThread({
        body: comment.body,
        attachments: comment.attachments,
        metadata: props.metadata ?? {}
      });
      onThreadCreate(thread.id);
    },
    [onThreadCreate, onComposerSubmit, props.metadata, createThread]
  );
  function handleKeyDown(event) {
    onKeyDown?.(event);
    if (event.isDefaultPrevented())
      return;
    if (event.key === "Escape") {
      onRangeChange(null);
      editor.focus();
    }
  }
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [
      /* @__PURE__ */ jsxRuntime.jsx(ActiveSelectionPortal, {
        range,
        container: document.body
      }),
      /* @__PURE__ */ jsxRuntime.jsx(FloatingComposerPortal, {
        range,
        container: document.body,
        children: /* @__PURE__ */ jsxRuntime.jsx(reactUi.Composer, {
          autoFocus: true,
          ...composerProps,
          onKeyDown: handleKeyDown,
          onComposerSubmit: handleComposerSubmit,
          ref: forwardedRef
        })
      })
    ]
  });
});
function ActiveSelectionPortal({
  range,
  container
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = reactDom.useFloating({
    strategy: "fixed",
    placement: "bottom",
    middleware: [reactDom.offset(-range.getBoundingClientRect().height)],
    whileElementsMounted: (...args) => {
      return reactDom.autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  _private.useLayoutEffect(() => {
    setReference(range);
  }, [setReference, range]);
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const rects = createRectsFromDomRange.createRectsFromDOMRange(editor, range);
  return reactDom$1.createPortal(
    /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, {
      children: /* @__PURE__ */ jsxRuntime.jsx("span", {
        ref: setFloating,
        style: {
          position: strategy,
          top: 0,
          left: 0,
          transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
          minWidth: "max-content",
          width: range.getBoundingClientRect().width,
          height: range.getBoundingClientRect().height,
          pointerEvents: "none"
        },
        className: "lb-root lb-portal",
        children: rects.map((rect) => /* @__PURE__ */ jsxRuntime.jsx("span", {
          style: {
            position: "absolute",
            top: rect.top - range.getBoundingClientRect().top,
            left: rect.left - range.getBoundingClientRect().left,
            width: rect.width,
            height: rect.height,
            backgroundColor: "var(--lb-selection, rgba(0, 0, 255, 0.2))",
            pointerEvents: "none"
          },
          className: "lb-selection lb-lexical-active-selection"
        }, JSON.stringify(rect)))
      })
    }),
    container
  );
}
const FLOATING_COMPOSER_COLLISION_PADDING = 10;
function FloatingComposerPortal({
  container,
  range,
  children
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = reactDom.useFloating({
    strategy: "fixed",
    placement: "bottom",
    middleware: [
      reactDom.inline({ padding: FLOATING_COMPOSER_COLLISION_PADDING }),
      reactDom.flip({ padding: FLOATING_COMPOSER_COLLISION_PADDING, crossAxis: false }),
      reactDom.offset(10),
      reactDom.hide({ padding: FLOATING_COMPOSER_COLLISION_PADDING }),
      reactDom.shift({
        padding: FLOATING_COMPOSER_COLLISION_PADDING,
        limiter: reactDom.limitShift()
      }),
      reactDom.size({ padding: FLOATING_COMPOSER_COLLISION_PADDING })
    ],
    whileElementsMounted: (...args) => {
      return reactDom.autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  _private.useLayoutEffect(() => {
    setReference(range);
  }, [range, setReference]);
  return reactDom$1.createPortal(
    /* @__PURE__ */ jsxRuntime.jsx("div", {
      ref: setFloating,
      style: {
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content"
      },
      className: "lb-root lb-portal lb-elevation lb-lexical-floating lb-lexical-floating-composer",
      children
    }),
    container
  );
}

exports.FLOATING_COMPOSER_COLLISION_PADDING = FLOATING_COMPOSER_COLLISION_PADDING;
exports.FloatingComposer = FloatingComposer;
exports.OPEN_FLOATING_COMPOSER_COMMAND = OPEN_FLOATING_COMPOSER_COMMAND;
//# sourceMappingURL=floating-composer.js.map
