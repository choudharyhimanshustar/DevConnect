import { $findMatchingParent } from '@lexical/utils';
import { $isRootOrShadowRoot, $getSelection, $isRangeSelection } from 'lexical';

function isParentRootOrShadowRoot(node) {
  const parent = node.getParent();
  return parent !== null && $isRootOrShadowRoot(parent);
}
const activeNodesByEditor = /* @__PURE__ */ new WeakMap();
function getActiveBlockNodes(editor) {
  const currentState = editor.getEditorState();
  return currentState.read(() => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      activeNodesByEditor.delete(editor);
      return [];
    }
    const cache = activeNodesByEditor.get(editor);
    if (cache?.state === currentState) {
      return cache.nodes;
    }
    const anchor = selection.anchor.getNode();
    const focus = selection.focus.getNode();
    const commonAncestor = anchor.getCommonAncestor(focus);
    let activeNodes = [];
    if (commonAncestor && !$isRootOrShadowRoot(commonAncestor)) {
      const activeNode = isParentRootOrShadowRoot(commonAncestor) ? commonAncestor : $findMatchingParent(commonAncestor, isParentRootOrShadowRoot);
      if (activeNode) {
        activeNodes = [activeNode];
      }
    } else {
      activeNodes = selection.getNodes().filter((node) => $isRootOrShadowRoot(node.getParent()));
    }
    activeNodesByEditor.set(editor, {
      state: currentState,
      nodes: activeNodes
    });
    return activeNodes;
  });
}
function isBlockNodeActive(editor, isActive) {
  const activeNodes = getActiveBlockNodes(editor);
  if (activeNodes.length === 0) {
    return false;
  }
  return activeNodes.every(isActive);
}

export { isBlockNodeActive };
//# sourceMappingURL=is-block-node-active.mjs.map
