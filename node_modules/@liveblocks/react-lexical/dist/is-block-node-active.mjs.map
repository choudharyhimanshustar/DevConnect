{"version":3,"file":"is-block-node-active.mjs","sources":["../src/is-block-node-active.ts"],"sourcesContent":["import { $findMatchingParent } from \"@lexical/utils\";\nimport type { EditorState, LexicalEditor, LexicalNode } from \"lexical\";\nimport { $getSelection, $isRangeSelection, $isRootOrShadowRoot } from \"lexical\";\n\nfunction isParentRootOrShadowRoot(node: LexicalNode) {\n  const parent = node.getParent();\n\n  return parent !== null && $isRootOrShadowRoot(parent);\n}\n\nconst activeNodesByEditor = new WeakMap<\n  LexicalEditor,\n  {\n    state: EditorState;\n    nodes: LexicalNode[];\n  }\n>();\n\nfunction getActiveBlockNodes(editor: LexicalEditor) {\n  const currentState = editor.getEditorState();\n\n  return currentState.read(() => {\n    const selection = $getSelection();\n\n    if (!$isRangeSelection(selection)) {\n      activeNodesByEditor.delete(editor);\n\n      return [];\n    }\n\n    const cache = activeNodesByEditor.get(editor);\n\n    if (cache?.state === currentState) {\n      return cache.nodes;\n    }\n\n    const anchor = selection.anchor.getNode();\n    const focus = selection.focus.getNode();\n    const commonAncestor = anchor.getCommonAncestor(focus);\n\n    let activeNodes: LexicalNode[] = [];\n\n    if (commonAncestor && !$isRootOrShadowRoot(commonAncestor)) {\n      const activeNode = isParentRootOrShadowRoot(commonAncestor)\n        ? commonAncestor\n        : $findMatchingParent(commonAncestor, isParentRootOrShadowRoot);\n\n      if (activeNode) {\n        activeNodes = [activeNode];\n      }\n    } else {\n      activeNodes = selection\n        .getNodes()\n        .filter((node) => $isRootOrShadowRoot(node.getParent()));\n    }\n\n    activeNodesByEditor.set(editor, {\n      state: currentState,\n      nodes: activeNodes,\n    });\n\n    return activeNodes;\n  });\n}\n\n/**\n * Checks if a block node is active in the current selection.\n * If the selection contains multiple block nodes, it will return\n * `true` only if all of them are of the same type.\n */\nexport function isBlockNodeActive(\n  editor: LexicalEditor,\n  isActive: (node: LexicalNode) => boolean\n): boolean {\n  const activeNodes = getActiveBlockNodes(editor);\n\n  if (activeNodes.length === 0) {\n    return false;\n  }\n\n  return activeNodes.every(isActive);\n}\n"],"names":[],"mappings":";;;AAIA,SAAS,yBAAyB,IAAmB,EAAA;AACnD,EAAM,MAAA,MAAA,GAAS,KAAK,SAAU,EAAA,CAAA;AAE9B,EAAO,OAAA,MAAA,KAAW,IAAQ,IAAA,mBAAA,CAAoB,MAAM,CAAA,CAAA;AACtD,CAAA;AAEA,MAAM,mBAAA,uBAA0B,OAM9B,EAAA,CAAA;AAEF,SAAS,oBAAoB,MAAuB,EAAA;AAClD,EAAM,MAAA,YAAA,GAAe,OAAO,cAAe,EAAA,CAAA;AAE3C,EAAO,OAAA,YAAA,CAAa,KAAK,MAAM;AAC7B,IAAA,MAAM,YAAY,aAAc,EAAA,CAAA;AAEhC,IAAI,IAAA,CAAC,iBAAkB,CAAA,SAAS,CAAG,EAAA;AACjC,MAAA,mBAAA,CAAoB,OAAO,MAAM,CAAA,CAAA;AAEjC,MAAA,OAAO,EAAC,CAAA;AAAA,KACV;AAEA,IAAM,MAAA,KAAA,GAAQ,mBAAoB,CAAA,GAAA,CAAI,MAAM,CAAA,CAAA;AAE5C,IAAI,IAAA,KAAA,EAAO,UAAU,YAAc,EAAA;AACjC,MAAA,OAAO,KAAM,CAAA,KAAA,CAAA;AAAA,KACf;AAEA,IAAM,MAAA,MAAA,GAAS,SAAU,CAAA,MAAA,CAAO,OAAQ,EAAA,CAAA;AACxC,IAAM,MAAA,KAAA,GAAQ,SAAU,CAAA,KAAA,CAAM,OAAQ,EAAA,CAAA;AACtC,IAAM,MAAA,cAAA,GAAiB,MAAO,CAAA,iBAAA,CAAkB,KAAK,CAAA,CAAA;AAErD,IAAA,IAAI,cAA6B,EAAC,CAAA;AAElC,IAAA,IAAI,cAAkB,IAAA,CAAC,mBAAoB,CAAA,cAAc,CAAG,EAAA;AAC1D,MAAA,MAAM,aAAa,wBAAyB,CAAA,cAAc,IACtD,cACA,GAAA,mBAAA,CAAoB,gBAAgB,wBAAwB,CAAA,CAAA;AAEhE,MAAA,IAAI,UAAY,EAAA;AACd,QAAA,WAAA,GAAc,CAAC,UAAU,CAAA,CAAA;AAAA,OAC3B;AAAA,KACK,MAAA;AACL,MAAc,WAAA,GAAA,SAAA,CACX,QAAS,EAAA,CACT,MAAO,CAAA,CAAC,SAAS,mBAAoB,CAAA,IAAA,CAAK,SAAU,EAAC,CAAC,CAAA,CAAA;AAAA,KAC3D;AAEA,IAAA,mBAAA,CAAoB,IAAI,MAAQ,EAAA;AAAA,MAC9B,KAAO,EAAA,YAAA;AAAA,MACP,KAAO,EAAA,WAAA;AAAA,KACR,CAAA,CAAA;AAED,IAAO,OAAA,WAAA,CAAA;AAAA,GACR,CAAA,CAAA;AACH,CAAA;AAOgB,SAAA,iBAAA,CACd,QACA,QACS,EAAA;AACT,EAAM,MAAA,WAAA,GAAc,oBAAoB,MAAM,CAAA,CAAA;AAE9C,EAAI,IAAA,WAAA,CAAY,WAAW,CAAG,EAAA;AAC5B,IAAO,OAAA,KAAA,CAAA;AAAA,GACT;AAEA,EAAO,OAAA,WAAA,CAAY,MAAM,QAAQ,CAAA,CAAA;AACnC;;;;"}