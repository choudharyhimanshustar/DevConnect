"use client";
import { jsx, jsxs } from 'react/jsx-runtime';
import { useLayoutEffect } from '@liveblocks/react/_private';
import { Slot } from '@radix-ui/react-slot';
import { useRef, useTransition, useState, useCallback, useEffect, forwardRef, useMemo } from 'react';
import { GroupedVirtuoso } from 'react-virtuoso';
import { isKey } from '../../utils/is-key.mjs';
import { requestIdleCallback, cancelIdleCallback } from '../../utils/request-idle-callback.mjs';
import { visuallyHidden } from '../../utils/visually-hidden.mjs';
import { Emoji } from '../internal/Emoji.mjs';
import { EmojiPickerContext, useEmojiPicker } from './contexts.mjs';
import { filterEmojis, generateEmojiPickerData, getEmojiData } from './utils.mjs';


const DEFAULT_COLUMNS = 10;
const DEFAULT_LOCALE = "en";
const LOADING_MINIMUM_TIMEOUT = 100;
const EMOJIPICKER_ROOT_NAME = "EmojiPickerRoot";
const EMOJIPICKER_CONTENT_NAME = "EmojiPickerContent";
const EMOJIPICKER_SEARCH_NAME = "EmojiPickerSearch";
function EmojiPickerRoot({
  columns = DEFAULT_COLUMNS,
  locale = DEFAULT_LOCALE,
  onEmojiSelect,
  children
}) {
  const emojiData = useRef();
  const search = useRef("");
  const [, startEmojisTransition] = useTransition();
  const [data, setData] = useState();
  const [error, setError] = useState();
  const [selectedColumnIndex, setSelectedColumnIndex] = useState(0);
  const [selectedRowIndex, setSelectedRowIndex] = useState(0);
  const [interaction, setInteraction] = useState("none");
  const selectCurrentEmoji = useCallback(() => {
    if (onEmojiSelect) {
      const emoji = data?.rows[selectedRowIndex]?.[selectedColumnIndex];
      if (emoji) {
        onEmojiSelect(emoji.emoji);
      }
    }
  }, [data?.rows, onEmojiSelect, selectedColumnIndex, selectedRowIndex]);
  const resetSelection = useCallback(() => {
    setSelectedColumnIndex(0);
    setSelectedRowIndex(0);
  }, []);
  const setPointerSelection = useCallback(
    (columnIndex, rowIndex) => {
      setInteraction("pointer");
      setSelectedColumnIndex(columnIndex);
      setSelectedRowIndex(rowIndex);
    },
    []
  );
  const moveSelection = useCallback(
    (direction, event) => {
      if (!data) {
        return;
      }
      event.preventDefault();
      if (interaction === "none") {
        setInteraction("keyboard");
        return;
      }
      setInteraction("keyboard");
      switch (direction) {
        case "left": {
          if (selectedColumnIndex === 0) {
            const previousRowIndex = selectedRowIndex - 1;
            const previousRow = data.rows[previousRowIndex];
            if (previousRow) {
              setSelectedRowIndex(previousRowIndex);
              setSelectedColumnIndex(previousRow.length - 1);
            }
          } else {
            setSelectedColumnIndex(selectedColumnIndex - 1);
          }
          break;
        }
        case "right": {
          const currentRow = data.rows[selectedRowIndex];
          if (!currentRow) {
            return;
          }
          if (selectedColumnIndex === currentRow.length - 1) {
            const nextRowIndex = selectedRowIndex + 1;
            const nextRow = data.rows[nextRowIndex];
            if (nextRow) {
              setSelectedRowIndex(nextRowIndex);
              setSelectedColumnIndex(0);
            }
          } else {
            setSelectedColumnIndex(selectedColumnIndex + 1);
          }
          break;
        }
        case "up": {
          const previousRow = data.rows[selectedRowIndex - 1];
          if (previousRow) {
            setSelectedRowIndex(selectedRowIndex - 1);
            if (!previousRow[selectedColumnIndex]) {
              setSelectedColumnIndex(previousRow.length - 1);
            }
          }
          break;
        }
        case "down": {
          const nextRow = data.rows[selectedRowIndex + 1];
          if (nextRow) {
            setSelectedRowIndex(selectedRowIndex + 1);
            if (!nextRow[selectedColumnIndex]) {
              setSelectedColumnIndex(nextRow.length - 1);
            }
          }
          break;
        }
      }
    },
    [data, interaction, selectedColumnIndex, selectedRowIndex]
  );
  const updateEmojis = useCallback(() => {
    if (!emojiData.current) {
      return;
    }
    startEmojisTransition(() => {
      setData(() => {
        if (!emojiData.current) {
          return;
        }
        const filteredEmojis = filterEmojis(
          emojiData.current.emojis,
          search.current
        );
        return generateEmojiPickerData(
          filteredEmojis,
          emojiData.current.categories,
          columns
        );
      });
      resetSelection();
    });
  }, [columns, resetSelection]);
  const handleSearch = useCallback(
    (value) => {
      search.current = value;
      updateEmojis();
    },
    [updateEmojis]
  );
  const initializeEmojiData = useCallback(
    async (locale2) => {
      try {
        emojiData.current = await getEmojiData(locale2);
        updateEmojis();
      } catch (error2) {
        setError(error2);
      }
    },
    [updateEmojis]
  );
  useEffect(() => {
    let idleCallbackId;
    const timeoutId = setTimeout(() => {
      idleCallbackId = requestIdleCallback(() => {
        initializeEmojiData(locale);
      });
    }, LOADING_MINIMUM_TIMEOUT);
    return () => {
      clearTimeout(timeoutId);
      cancelIdleCallback(idleCallbackId);
    };
  }, [locale]);
  useEffect(() => {
    if (interaction === "none") {
      resetSelection();
    }
  }, [interaction]);
  return /* @__PURE__ */ jsx(EmojiPickerContext.Provider, {
    value: {
      data,
      error,
      isLoading: !data && !error,
      columns,
      onSearch: handleSearch,
      onEmojiSelect,
      selectCurrentEmoji,
      selectedRowIndex,
      selectedColumnIndex,
      moveSelection,
      setPointerSelection,
      interaction,
      setInteraction
    },
    children
  });
}
const EmojiPickerSearch = forwardRef(
  ({ asChild, value, defaultValue, onChange, ...props }, forwardedRef) => {
    const Component = asChild ? Slot : "input";
    const {
      onSearch,
      selectCurrentEmoji,
      moveSelection,
      interaction,
      setInteraction
    } = useEmojiPicker();
    const handleChange = useCallback(
      (event) => {
        onChange?.(event);
        if (event.isDefaultPrevented()) {
          return;
        }
        const value2 = event.target.value;
        setInteraction(value2 ? "keyboard" : "none");
        onSearch(value2);
      },
      [onChange, onSearch, setInteraction]
    );
    const handleKeyDown = useCallback(
      (event) => {
        if (event.isDefaultPrevented()) {
          return;
        }
        if (isKey(event, "ArrowLeft")) {
          moveSelection("left", event);
        } else if (isKey(event, "ArrowRight")) {
          moveSelection("right", event);
        } else if (isKey(event, "ArrowUp")) {
          moveSelection("up", event);
        } else if (isKey(event, "ArrowDown")) {
          moveSelection("down", event);
        } else if (isKey(event, "Enter")) {
          if (interaction !== "none") {
            event.preventDefault();
            selectCurrentEmoji();
          }
        }
      },
      [interaction, moveSelection, selectCurrentEmoji]
    );
    useEffect(() => {
      onSearch(
        value ? String(value) : defaultValue ? String(defaultValue) : ""
      );
    }, []);
    return /* @__PURE__ */ jsx(Component, {
      type: "search",
      value,
      defaultValue,
      onChange: handleChange,
      onKeyDown: handleKeyDown,
      ...props,
      ref: forwardedRef
    });
  }
);
const defaultContentComponents = {
  CategoryHeader: ({ category, ...props }) => /* @__PURE__ */ jsx("div", {
    ...props,
    children: category
  }),
  Row: ({ children, attributes, ...props }) => /* @__PURE__ */ jsx("div", {
    ...props,
    children
  }),
  Emoji: ({ emoji, ...props }) => /* @__PURE__ */ jsx("button", {
    ...props,
    children: /* @__PURE__ */ jsx(Emoji, {
      emoji
    })
  }),
  Loading: (props) => /* @__PURE__ */ jsx("div", {
    ...props
  }),
  Empty: (props) => /* @__PURE__ */ jsx("div", {
    ...props
  }),
  Grid: (props) => /* @__PURE__ */ jsx("div", {
    ...props
  }),
  Error: ({ error, ...props }) => /* @__PURE__ */ jsx("div", {
    ...props
  })
};
const placeholderRowAttributes = {
  rowIndex: -1,
  categoryRowIndex: -1,
  categoryRowsCount: 0
};
const VirtuosoScroller = forwardRef(
  ({ children, ...props }, forwardedRef) => {
    return /* @__PURE__ */ jsx("div", {
      ...props,
      tabIndex: -1,
      "data-testid": void 0,
      ref: forwardedRef,
      children
    });
  }
);
const VirtuosoTopList = forwardRef(
  ({ children, ...props }, forwardedRef) => {
    return /* @__PURE__ */ jsx("div", {
      ...props,
      "data-testid": void 0,
      ref: forwardedRef,
      children
    });
  }
);
const EmojiPickerContent = forwardRef(
  ({ components, asChild, ...props }, forwardedRef) => {
    const Component = asChild ? Slot : "div";
    const virtuosoRef = useRef(null);
    const placeholderContainerRef = useRef(null);
    const rowScrollMarginTopRef = useRef(0);
    const rowScrollMarginBottomRef = useRef(0);
    const categoryHeaderHeightRef = useRef(0);
    const {
      data,
      error,
      isLoading,
      columns,
      onEmojiSelect,
      selectedColumnIndex,
      selectedRowIndex,
      setPointerSelection,
      interaction,
      setInteraction
    } = useEmojiPicker();
    const selectedEmoji = useMemo(
      () => data?.rows[selectedRowIndex]?.[selectedColumnIndex],
      [data?.rows, selectedColumnIndex, selectedRowIndex]
    );
    const { Loading, Empty, Error, CategoryHeader, Grid, Row, Emoji } = useMemo(
      () => ({ ...defaultContentComponents, ...components }),
      [components]
    );
    const VirtuosoList = useMemo(
      () => forwardRef(
        ({ children, ...props2 }, forwardedRef2) => {
          return /* @__PURE__ */ jsx("div", {
            role: "grid",
            "aria-colcount": columns,
            ...props2,
            "data-testid": void 0,
            ref: forwardedRef2,
            children
          });
        }
      ),
      [columns]
    );
    const placeholderColumns = useMemo(
      () => Array(columns).fill("\u{1F32B}\uFE0F"),
      [columns]
    );
    const preventDefault = useCallback((event) => {
      event.preventDefault();
    }, []);
    const handleEmojiPointerLeave = useCallback(() => {
      if (interaction === "pointer") {
        setInteraction("none");
      }
    }, [interaction, setInteraction]);
    useLayoutEffect(() => {
      if (!placeholderContainerRef.current) {
        return;
      }
      const row = placeholderContainerRef.current.childNodes[0];
      const categoryHeader = placeholderContainerRef.current.childNodes[1];
      if (row instanceof HTMLElement) {
        const style = window.getComputedStyle(row);
        rowScrollMarginTopRef.current = parseFloat(style.scrollMarginTop);
        rowScrollMarginBottomRef.current = parseFloat(style.scrollMarginBottom);
      }
      if (categoryHeader instanceof HTMLElement) {
        categoryHeaderHeightRef.current = categoryHeader.offsetHeight;
      }
    }, []);
    const calculateViewLocation = useCallback(
      ({
        itemTop,
        itemBottom,
        viewportTop,
        viewportBottom,
        locationParams: { behavior, align, ...params }
      }) => {
        if (itemTop - (categoryHeaderHeightRef.current + rowScrollMarginTopRef.current) < viewportTop) {
          return {
            ...params,
            behavior,
            align: align ?? "start"
          };
        }
        if (itemBottom > viewportBottom) {
          return {
            ...params,
            behavior,
            align: align ?? "end",
            offset: rowScrollMarginBottomRef.current
          };
        }
        return null;
      },
      []
    );
    useEffect(() => {
      if (interaction === "keyboard") {
        virtuosoRef.current?.scrollIntoView({
          index: selectedRowIndex,
          behavior: "auto",
          calculateViewLocation
        });
      }
    }, [interaction, selectedRowIndex, calculateViewLocation]);
    return /* @__PURE__ */ jsxs(Component, {
      ...props,
      ref: forwardedRef,
      children: [
        /* @__PURE__ */ jsxs("div", {
          style: {
            visibility: "hidden",
            height: 0
          },
          ref: placeholderContainerRef,
          children: [
            /* @__PURE__ */ jsx(Row, {
              attributes: placeholderRowAttributes,
              children: placeholderColumns.map((placeholder, index) => /* @__PURE__ */ jsx(Emoji, {
                emoji: placeholder
              }, index))
            }),
            /* @__PURE__ */ jsx(CategoryHeader, {
              category: "Category"
            })
          ]
        }),
        isLoading ? /* @__PURE__ */ jsx(Loading, {}) : error ? /* @__PURE__ */ jsx(Error, {
          error
        }) : data.count === 0 ? /* @__PURE__ */ jsx(Empty, {}) : /* @__PURE__ */ jsx(Grid, {
          children: /* @__PURE__ */ jsx(GroupedVirtuoso, {
            ref: virtuosoRef,
            components: {
              Scroller: VirtuosoScroller,
              List: VirtuosoList,
              TopItemList: VirtuosoTopList
            },
            groupCounts: data.categoriesRowCounts,
            groupContent: (groupIndex) => {
              const category = data.categories[groupIndex];
              if (!category) {
                return null;
              }
              return /* @__PURE__ */ jsx(CategoryHeader, {
                category
              });
            },
            itemContent: (rowIndex, groupIndex) => {
              const categoryRow = data.rows[rowIndex];
              const categoryRowIndex = data.categoriesRowIndices[groupIndex]?.indexOf(rowIndex);
              const categoryRowsCount = data.categoriesRowCounts[groupIndex];
              if (categoryRow === void 0 || categoryRowIndex === void 0 || categoryRowsCount === void 0) {
                return null;
              }
              return /* @__PURE__ */ jsx(Row, {
                attributes: {
                  rowIndex,
                  categoryRowIndex,
                  categoryRowsCount
                },
                children: categoryRow.map((emoji, columnIndex) => {
                  const isSelected = interaction !== "none" && selectedColumnIndex === columnIndex && selectedRowIndex === rowIndex;
                  return /* @__PURE__ */ jsx(Emoji, {
                    role: "gridcell",
                    "aria-colindex": columnIndex,
                    "aria-selected": isSelected || void 0,
                    "data-selected": isSelected || void 0,
                    onMouseDown: preventDefault,
                    tabIndex: -1,
                    onPointerEnter: () => {
                      setPointerSelection(columnIndex, rowIndex);
                    },
                    onPointerLeave: handleEmojiPointerLeave,
                    onClick: (event) => {
                      onEmojiSelect?.(emoji.emoji);
                      event.stopPropagation();
                    },
                    emoji: emoji.emoji
                  }, emoji.emoji);
                })
              });
            }
          })
        }),
        selectedEmoji && interaction !== "none" && /* @__PURE__ */ jsx("div", {
          "aria-live": "polite",
          style: visuallyHidden,
          children: selectedEmoji.name
        })
      ]
    });
  }
);
if (process.env.NODE_ENV !== "production") {
  EmojiPickerRoot.displayName = EMOJIPICKER_ROOT_NAME;
  EmojiPickerContent.displayName = EMOJIPICKER_CONTENT_NAME;
  EmojiPickerSearch.displayName = EMOJIPICKER_SEARCH_NAME;
}

export { EmojiPickerContent as Content, EmojiPickerRoot as Root, EmojiPickerSearch as Search };
//# sourceMappingURL=index.mjs.map
