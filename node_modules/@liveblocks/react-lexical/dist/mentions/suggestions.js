'use strict';

var jsxRuntime = require('react/jsx-runtime');
var LexicalComposerContext = require('@lexical/react/LexicalComposerContext');
var lexical = require('lexical');
var react = require('react');

const SuggestionsContext = react.createContext(null);
const OnValueSelectCallbackContext = react.createContext(null);
const OnResetMatchCallbackContext = react.createContext(
  null
);
const HighlightedIndexContext = react.createContext(null);
const List = react.forwardRef(
  function(props, forwardedRef) {
    const { children, ...divProps } = props;
    const [editor] = LexicalComposerContext.useLexicalComposerContext();
    const [highlightedIndex, setHighlightedIndex] = react.useState(0);
    const values = useSuggestions();
    const onValueSelect = useOnValueSelectCallback();
    const onEscapeKeyDown = useOnResetMatchCallback();
    react.useEffect(() => {
      function onKeyArrowDown(event) {
        if (values.length === 0)
          return true;
        if (highlightedIndex === null)
          return true;
        const nextIndex = highlightedIndex === values.length - 1 ? 0 : highlightedIndex + 1;
        setHighlightedIndex(nextIndex);
        event.preventDefault();
        event.stopImmediatePropagation();
        return true;
      }
      return editor.registerCommand(
        lexical.KEY_ARROW_DOWN_COMMAND,
        onKeyArrowDown,
        lexical.COMMAND_PRIORITY_LOW
      );
    }, [editor, highlightedIndex, values]);
    react.useEffect(() => {
      function onKeyArrowUp(event) {
        if (values.length === 0)
          return true;
        if (highlightedIndex === null)
          return true;
        const nextIndex = highlightedIndex === 0 ? values.length - 1 : highlightedIndex - 1;
        setHighlightedIndex(nextIndex);
        event.preventDefault();
        event.stopImmediatePropagation();
        return true;
      }
      return editor.registerCommand(
        lexical.KEY_ARROW_UP_COMMAND,
        onKeyArrowUp,
        lexical.COMMAND_PRIORITY_LOW
      );
    }, [editor, highlightedIndex, values]);
    react.useEffect(() => {
      function onKeyEscape(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        onEscapeKeyDown();
        return true;
      }
      return editor.registerCommand(
        lexical.KEY_ESCAPE_COMMAND,
        onKeyEscape,
        lexical.COMMAND_PRIORITY_LOW
      );
    }, [editor, onEscapeKeyDown]);
    react.useEffect(() => {
      function onKeyEnter(event) {
        if (values.length === 0)
          return true;
        onValueSelect(values[highlightedIndex]);
        if (event === null)
          return true;
        event.preventDefault();
        event.stopImmediatePropagation();
        return true;
      }
      return editor.registerCommand(
        lexical.KEY_ENTER_COMMAND,
        onKeyEnter,
        lexical.COMMAND_PRIORITY_LOW
      );
    }, [editor, onValueSelect, highlightedIndex, values]);
    react.useEffect(() => {
      const root = editor.getRootElement();
      if (root === null)
        return;
      root.setAttribute(
        "aria-activedescendant",
        `typeahead-item-${highlightedIndex}`
      );
      return () => {
        root.removeAttribute("aria-activedescendant");
      };
    }, [editor, highlightedIndex]);
    return /* @__PURE__ */ jsxRuntime.jsx(HighlightedIndexContext.Provider, {
      value: [highlightedIndex, setHighlightedIndex],
      children: /* @__PURE__ */ jsxRuntime.jsx("div", {
        role: "listbox",
        ...divProps,
        ref: forwardedRef,
        children
      })
    });
  }
);
const Item = react.forwardRef(
  function Item2(props, forwardedRef) {
    const { children, value, onMouseEnter, onClick, ...divProps } = props;
    const divRef = react.useRef(null);
    const [highlightedIndex, setHighlightedIndex] = useHighlightedIndex();
    const suggestions = useSuggestions();
    const onValueSelect = useOnValueSelectCallback();
    const isHighlighted = suggestions[highlightedIndex] === value;
    react.useImperativeHandle(
      forwardedRef,
      () => divRef.current
    );
    react.useEffect(() => {
      if (!isHighlighted)
        return;
      const div = divRef.current;
      if (div === null)
        return;
      div.scrollIntoView({ block: "nearest" });
    }, [isHighlighted]);
    function handleMouseEnter(event) {
      onMouseEnter?.(event);
      if (event.isDefaultPrevented())
        return;
      const index = suggestions.indexOf(value);
      if (index === -1)
        return;
      setHighlightedIndex(index);
    }
    function handleClick(event) {
      onClick?.(event);
      if (event.isDefaultPrevented())
        return;
      onValueSelect(value);
    }
    return /* @__PURE__ */ jsxRuntime.jsx("div", {
      role: "option",
      "data-highlighted": isHighlighted || void 0,
      onMouseEnter: handleMouseEnter,
      onClick: handleClick,
      ...divProps,
      ref: divRef,
      children
    });
  }
);
function useHighlightedIndex() {
  const context = react.useContext(HighlightedIndexContext);
  if (context === null) {
    throw new Error(
      "useHighlightedIndex must be used within a HighlightedIndexProvider"
    );
  }
  return context;
}
function useSuggestions() {
  const suggestions = react.useContext(SuggestionsContext);
  if (suggestions === null) {
    throw new Error("useSuggestions: SuggestionsContext not found");
  }
  return suggestions;
}
function useOnValueSelectCallback() {
  const onValueSelect = react.useContext(OnValueSelectCallbackContext);
  if (onValueSelect === null) {
    throw new Error("useOnValueSelectCallback: OnValueSelectContext not found");
  }
  return onValueSelect;
}
function useOnResetMatchCallback() {
  const onResetMatch = react.useContext(OnResetMatchCallbackContext);
  if (onResetMatch === null) {
    throw new Error("useOnResetMatchCallback: OnResetMatchContext not found");
  }
  return onResetMatch;
}

exports.Item = Item;
exports.List = List;
exports.OnResetMatchCallbackContext = OnResetMatchCallbackContext;
exports.OnValueSelectCallbackContext = OnValueSelectCallbackContext;
exports.SuggestionsContext = SuggestionsContext;
//# sourceMappingURL=suggestions.js.map
