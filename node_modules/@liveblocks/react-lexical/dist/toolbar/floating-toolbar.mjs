import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { inline, flip, hide, shift, limitShift, offset, size, autoUpdate, useFloating } from '@floating-ui/react-dom';
import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';
import { useInitial, useRefs, TooltipProvider } from '@liveblocks/react-ui/_private';
import { FORMAT_TEXT_COMMAND, $getSelection, $isRangeSelection } from 'lexical';
import { forwardRef, useRef, useState, useEffect, useCallback, useMemo } from 'react';
import { createPortal } from 'react-dom';
import { classNames } from '../classnames.mjs';
import { OPEN_FLOATING_COMPOSER_COMMAND } from '../comments/floating-composer.mjs';
import { createDOMRange } from '../create-dom-range.mjs';
import { useIsCommandRegistered } from '../is-command-registered.mjs';
import { useRootElement } from '../use-root-element.mjs';
import { FloatingToolbarContext, FloatingToolbarExternal } from './shared.mjs';
import { Toolbar, applyToolbarSlot } from './toolbar.mjs';

const FLOATING_TOOLBAR_COLLISION_PADDING = 10;
const FLOATING_TOOLBAR_OPEN_DELAY = 50;
function DefaultFloatingToolbarContent() {
  const supportsTextFormat = useIsCommandRegistered(FORMAT_TEXT_COMMAND);
  const supportsThread = useIsCommandRegistered(OPEN_FLOATING_COMPOSER_COMMAND);
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [
      supportsTextFormat ? /* @__PURE__ */ jsxs(Fragment, {
        children: [
          /* @__PURE__ */ jsx(Toolbar.BlockSelector, {}),
          /* @__PURE__ */ jsx(Toolbar.SectionInline, {})
        ]
      }) : null,
      supportsThread ? /* @__PURE__ */ jsxs(Fragment, {
        children: [
          /* @__PURE__ */ jsx(Toolbar.Separator, {}),
          /* @__PURE__ */ jsx(Toolbar.SectionCollaboration, {})
        ]
      }) : null
    ]
  });
}
const FloatingToolbar = Object.assign(
  forwardRef(
    ({
      children = DefaultFloatingToolbarContent,
      before,
      after,
      position = "top",
      offset: sideOffset = 6,
      onPointerDown,
      onFocus,
      onBlur,
      className,
      ...props
    }, forwardedRef) => {
      const toolbarRef = useRef(null);
      const externalIds = useInitial(() => /* @__PURE__ */ new Set());
      const [isPointerDown, setPointerDown] = useState(false);
      const [editor] = useLexicalComposerContext();
      const root = useRootElement();
      const [isFocused, setFocused] = useState(false);
      const [isManuallyClosed, setManuallyClosed] = useState(false);
      const [hasSelectionRange, setHasSelectionRange] = useState(false);
      const isOpen = isFocused && !isPointerDown && hasSelectionRange && !isManuallyClosed;
      const [delayedIsOpen, setDelayedIsOpen] = useState(isOpen);
      const delayedIsOpenTimeoutRef = useRef();
      useEffect(() => {
        setManuallyClosed(false);
      }, [isFocused, hasSelectionRange, editor]);
      useEffect(() => {
        if (!root) {
          return;
        }
        const handleFocus2 = () => {
          setFocused(true);
        };
        const handleBlur2 = (event) => {
          if (event.relatedTarget && toolbarRef.current?.contains(event.relatedTarget)) {
            return;
          }
          if (event.relatedTarget === root) {
            return;
          }
          for (const externalId of externalIds) {
            if (document.getElementById(externalId)?.contains(event.relatedTarget)) {
              return;
            }
          }
          setFocused(false);
        };
        root.addEventListener("focus", handleFocus2);
        root.addEventListener("blur", handleBlur2);
        return () => {
          root.removeEventListener("focus", handleFocus2);
          root.removeEventListener("blur", handleBlur2);
        };
      }, [root, externalIds]);
      const handleFocus = useCallback(
        (event) => {
          onFocus?.(event);
          if (!event.isDefaultPrevented()) {
            setFocused(true);
          }
        },
        [onFocus]
      );
      const handleBlur = useCallback(
        (event) => {
          onBlur?.(event);
          if (!event.isDefaultPrevented()) {
            if (event.relatedTarget && toolbarRef.current?.contains(event.relatedTarget)) {
              return;
            }
            if (event.relatedTarget === root) {
              return;
            }
            for (const externalId of externalIds) {
              if (document.getElementById(externalId)?.contains(event.relatedTarget)) {
                return;
              }
            }
            setFocused(false);
          }
        },
        [onBlur, root, externalIds]
      );
      useEffect(() => {
        if (isOpen) {
          delayedIsOpenTimeoutRef.current = window.setTimeout(() => {
            setDelayedIsOpen(true);
          }, FLOATING_TOOLBAR_OPEN_DELAY);
        } else {
          setDelayedIsOpen(false);
        }
        return () => {
          window.clearTimeout(delayedIsOpenTimeoutRef.current);
        };
      }, [isOpen]);
      const floatingOptions = useMemo(() => {
        const detectOverflowOptions = {
          padding: FLOATING_TOOLBAR_COLLISION_PADDING
        };
        return {
          strategy: "fixed",
          placement: position,
          middleware: [
            inline(detectOverflowOptions),
            flip({ ...detectOverflowOptions, crossAxis: false }),
            hide(detectOverflowOptions),
            shift({
              ...detectOverflowOptions,
              limiter: limitShift()
            }),
            offset(sideOffset),
            size(detectOverflowOptions)
          ],
          whileElementsMounted: (...args) => {
            return autoUpdate(...args, {
              animationFrame: true
            });
          }
        };
      }, [position, sideOffset]);
      const {
        refs: { setReference, setFloating },
        strategy,
        x,
        y,
        isPositioned
      } = useFloating({
        ...floatingOptions,
        open: delayedIsOpen
      });
      const mergedRefs = useRefs(forwardedRef, toolbarRef, setFloating);
      const handlePointerDown = useCallback(
        (event) => {
          onPointerDown?.(event);
          event.stopPropagation();
          if (event.target === toolbarRef.current) {
            event.preventDefault();
          }
        },
        [onPointerDown]
      );
      useEffect(() => {
        const handlePointerDown2 = () => {
          setPointerDown(true);
        };
        const handlePointerUp = () => {
          setPointerDown(false);
        };
        if (!root) {
          return;
        }
        root.addEventListener("pointerdown", handlePointerDown2);
        document.addEventListener("pointercancel", handlePointerUp);
        document.addEventListener("pointerup", handlePointerUp);
        return () => {
          root.removeEventListener("pointerdown", handlePointerDown2);
          document.removeEventListener("pointercancel", handlePointerUp);
          document.removeEventListener("pointerup", handlePointerUp);
        };
      }, [root]);
      useEffect(() => {
        const unregister = editor.registerUpdateListener(({ tags }) => {
          return editor.getEditorState().read(() => {
            if (tags.has("collaboration"))
              return;
            setManuallyClosed(false);
            const selection = $getSelection();
            if (!$isRangeSelection(selection) || selection.isCollapsed()) {
              setHasSelectionRange(false);
              setReference(null);
              return;
            }
            const { anchor, focus } = selection;
            const range = createDOMRange(
              editor,
              anchor.getNode(),
              anchor.offset,
              focus.getNode(),
              focus.offset
            );
            setHasSelectionRange(true);
            setReference(range);
          });
        });
        return unregister;
      }, [editor, setReference]);
      useEffect(() => {
        const root2 = editor.getRootElement();
        if (!root2 || !delayedIsOpen) {
          return;
        }
        const handleKeyDown = (event) => {
          if (event.target !== root2 && event.defaultPrevented) {
            return;
          }
          if (event.key === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            editor.focus();
            setManuallyClosed(true);
          }
        };
        root2.addEventListener("keydown", handleKeyDown);
        return () => {
          root2.removeEventListener("keydown", handleKeyDown);
        };
      }, [editor, delayedIsOpen]);
      const close = useCallback(() => {
        editor.focus();
        setManuallyClosed(true);
      }, [editor, setManuallyClosed]);
      const registerExternal = useCallback(
        (id) => {
          externalIds.add(id);
          return () => {
            externalIds.delete(id);
          };
        },
        [externalIds]
      );
      if (!delayedIsOpen) {
        return null;
      }
      const slotProps = { editor };
      return createPortal(
        /* @__PURE__ */ jsx(TooltipProvider, {
          children: /* @__PURE__ */ jsx(FloatingToolbarContext.Provider, {
            value: { close, registerExternal },
            children: /* @__PURE__ */ jsxs("div", {
              role: "toolbar",
              "aria-label": "Floating toolbar",
              "aria-orientation": "horizontal",
              className: classNames(
                "lb-root lb-portal lb-elevation lb-lexical-floating-toolbar lb-lexical-toolbar",
                className
              ),
              ref: mergedRefs,
              style: {
                position: strategy,
                top: 0,
                left: 0,
                transform: isPositioned ? `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)` : "translate3d(0, -200%, 0)",
                minWidth: "max-content"
              },
              onPointerDown: handlePointerDown,
              onFocus: handleFocus,
              onBlur: handleBlur,
              ...props,
              children: [
                applyToolbarSlot(before, slotProps),
                applyToolbarSlot(children, slotProps),
                applyToolbarSlot(after, slotProps)
              ]
            })
          })
        }),
        document.body
      );
    }
  ),
  {
    External: FloatingToolbarExternal
  }
);

export { FLOATING_TOOLBAR_COLLISION_PADDING, FloatingToolbar };
//# sourceMappingURL=floating-toolbar.mjs.map
