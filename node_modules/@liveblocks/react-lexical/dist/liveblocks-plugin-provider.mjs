import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { useFloating, autoUpdate } from '@floating-ui/react-dom';
import { CollaborationPlugin } from '@lexical/react/LexicalCollaborationPlugin';
import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';
import { TextEditorType, nn } from '@liveblocks/core';
import { useRoom, useSelf } from '@liveblocks/react';
import { useYjsProvider, useResolveMentionSuggestions, useReportTextEditor, useLayoutEffect } from '@liveblocks/react/_private';
import { LiveblocksYjsProvider } from '@liveblocks/yjs';
import { useCallback, useSyncExternalStore, useRef, useState, useEffect } from 'react';
import { Doc } from 'yjs';
import { CommentPluginProvider } from './comments/comment-plugin-provider.mjs';
import { ThreadMarkNode } from './comments/thread-mark-node.mjs';
import { MentionNode } from './mentions/mention-node.mjs';
import { MentionPlugin } from './mentions/mention-plugin.mjs';
import { useRootElement } from './use-root-element.mjs';

const providersMap = /* @__PURE__ */ new Map();
function useEditorStatus() {
  const provider = useYjsProvider();
  const subscribe = useCallback(
    (onStoreChange) => {
      if (provider === void 0)
        return () => {
        };
      provider.on("status", onStoreChange);
      return () => {
        provider.off("status", onStoreChange);
      };
    },
    [provider]
  );
  const getSnapshot = useCallback(() => {
    if (provider === void 0) {
      return "not-loaded";
    }
    return provider.getStatus();
  }, [provider]);
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
function useIsEditorReady() {
  const yjsProvider = useYjsProvider();
  const getSnapshot = useCallback(() => {
    const status = yjsProvider?.getStatus();
    return status === "synchronizing" || status === "synchronized";
  }, [yjsProvider]);
  const subscribe = useCallback(
    (callback) => {
      if (yjsProvider === void 0)
        return () => {
        };
      yjsProvider.on("status", callback);
      return () => {
        yjsProvider.off("status", callback);
      };
    },
    [yjsProvider]
  );
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
const LiveblocksPlugin = ({
  children
}) => {
  const isResolveMentionSuggestionsDefined = useResolveMentionSuggestions() !== void 0;
  const [editor] = useLexicalComposerContext();
  const room = useRoom();
  const previousRoomIdRef = useRef(null);
  if (!editor.hasNodes([ThreadMarkNode, MentionNode])) {
    throw new Error(
      "LiveblocksPlugin requires Lexical configuration to be wrapped in the `liveblocksConfig(options)` function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-react-lexical#liveblocksConfig"
    );
  }
  const [containerRef, setContainerRef] = useState(void 0);
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = useFloating({
    strategy: "fixed",
    placement: "bottom",
    whileElementsMounted: (...args) => {
      return autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  useEffect(() => {
    if (process.env.NODE_ENV !== "production") {
      if (!editor.getEditorState().isEmpty()) {
        console.warn(
          "Warning: LiveblocksPlugin: editorState in initialConfig detected, but must be null."
        );
      }
    }
  }, []);
  useReportTextEditor(TextEditorType.Lexical, "root");
  const self = useSelf();
  const providerFactory = useCallback(
    (id, yjsDocMap) => {
      if (previousRoomIdRef.current !== null && previousRoomIdRef.current !== id) {
        const previousProvider = providersMap.get(id);
        if (previousProvider !== void 0) {
          previousProvider.destroy();
        }
      }
      let doc = yjsDocMap.get(id);
      if (doc === void 0) {
        doc = new Doc();
        const provider = new LiveblocksYjsProvider(room, doc);
        yjsDocMap.set(id, doc);
        providersMap.set(id, provider);
      }
      return nn(
        providersMap.get(id),
        "Internal error. Should never happen"
      );
    },
    [room]
  );
  const root = useRootElement();
  useLayoutEffect(() => {
    if (root === null)
      return;
    setReference({
      getBoundingClientRect: () => root.getBoundingClientRect()
    });
  }, [setReference, root]);
  const handleFloatingRef = useCallback(
    (node) => {
      setFloating(node);
      setContainerRef({ current: node });
    },
    [setFloating, setContainerRef]
  );
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [
      /* @__PURE__ */ jsx("div", {
        ref: handleFloatingRef,
        style: {
          position: strategy,
          top: 0,
          left: 0,
          transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
          minWidth: "max-content"
        }
      }),
      self && /* @__PURE__ */ jsx(CollaborationPlugin, {
        id: room.id,
        providerFactory,
        username: self.info?.name ?? "",
        cursorColor: self.info?.color,
        cursorsContainerRef: containerRef,
        shouldBootstrap: true
      }, room.id),
      isResolveMentionSuggestionsDefined && /* @__PURE__ */ jsx(MentionPlugin, {}),
      /* @__PURE__ */ jsx(CommentPluginProvider, {
        children
      })
    ]
  });
};

export { LiveblocksPlugin, useEditorStatus, useIsEditorReady };
//# sourceMappingURL=liveblocks-plugin-provider.mjs.map
