'use strict';

var jsxRuntime = require('react/jsx-runtime');
var reactDom = require('@floating-ui/react-dom');
var LexicalComposerContext = require('@lexical/react/LexicalComposerContext');
var _private = require('@liveblocks/react-ui/_private');
var lexical = require('lexical');
var react = require('react');
var reactDom$1 = require('react-dom');
var classnames = require('../classnames.js');
var floatingComposer = require('../comments/floating-composer.js');
var createDomRange = require('../create-dom-range.js');
var isCommandRegistered = require('../is-command-registered.js');
var useRootElement = require('../use-root-element.js');
var shared = require('./shared.js');
var toolbar = require('./toolbar.js');

const FLOATING_TOOLBAR_COLLISION_PADDING = 10;
const FLOATING_TOOLBAR_OPEN_DELAY = 50;
function DefaultFloatingToolbarContent() {
  const supportsTextFormat = isCommandRegistered.useIsCommandRegistered(lexical.FORMAT_TEXT_COMMAND);
  const supportsThread = isCommandRegistered.useIsCommandRegistered(floatingComposer.OPEN_FLOATING_COMPOSER_COMMAND);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [
      supportsTextFormat ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(toolbar.Toolbar.BlockSelector, {}),
          /* @__PURE__ */ jsxRuntime.jsx(toolbar.Toolbar.SectionInline, {})
        ]
      }) : null,
      supportsThread ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(toolbar.Toolbar.Separator, {}),
          /* @__PURE__ */ jsxRuntime.jsx(toolbar.Toolbar.SectionCollaboration, {})
        ]
      }) : null
    ]
  });
}
const FloatingToolbar = Object.assign(
  react.forwardRef(
    ({
      children = DefaultFloatingToolbarContent,
      before,
      after,
      position = "top",
      offset: sideOffset = 6,
      onPointerDown,
      onFocus,
      onBlur,
      className,
      ...props
    }, forwardedRef) => {
      const toolbarRef = react.useRef(null);
      const externalIds = _private.useInitial(() => /* @__PURE__ */ new Set());
      const [isPointerDown, setPointerDown] = react.useState(false);
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const root = useRootElement.useRootElement();
      const [isFocused, setFocused] = react.useState(false);
      const [isManuallyClosed, setManuallyClosed] = react.useState(false);
      const [hasSelectionRange, setHasSelectionRange] = react.useState(false);
      const isOpen = isFocused && !isPointerDown && hasSelectionRange && !isManuallyClosed;
      const [delayedIsOpen, setDelayedIsOpen] = react.useState(isOpen);
      const delayedIsOpenTimeoutRef = react.useRef();
      react.useEffect(() => {
        setManuallyClosed(false);
      }, [isFocused, hasSelectionRange, editor]);
      react.useEffect(() => {
        if (!root) {
          return;
        }
        const handleFocus2 = () => {
          setFocused(true);
        };
        const handleBlur2 = (event) => {
          if (event.relatedTarget && toolbarRef.current?.contains(event.relatedTarget)) {
            return;
          }
          if (event.relatedTarget === root) {
            return;
          }
          for (const externalId of externalIds) {
            if (document.getElementById(externalId)?.contains(event.relatedTarget)) {
              return;
            }
          }
          setFocused(false);
        };
        root.addEventListener("focus", handleFocus2);
        root.addEventListener("blur", handleBlur2);
        return () => {
          root.removeEventListener("focus", handleFocus2);
          root.removeEventListener("blur", handleBlur2);
        };
      }, [root, externalIds]);
      const handleFocus = react.useCallback(
        (event) => {
          onFocus?.(event);
          if (!event.isDefaultPrevented()) {
            setFocused(true);
          }
        },
        [onFocus]
      );
      const handleBlur = react.useCallback(
        (event) => {
          onBlur?.(event);
          if (!event.isDefaultPrevented()) {
            if (event.relatedTarget && toolbarRef.current?.contains(event.relatedTarget)) {
              return;
            }
            if (event.relatedTarget === root) {
              return;
            }
            for (const externalId of externalIds) {
              if (document.getElementById(externalId)?.contains(event.relatedTarget)) {
                return;
              }
            }
            setFocused(false);
          }
        },
        [onBlur, root, externalIds]
      );
      react.useEffect(() => {
        if (isOpen) {
          delayedIsOpenTimeoutRef.current = window.setTimeout(() => {
            setDelayedIsOpen(true);
          }, FLOATING_TOOLBAR_OPEN_DELAY);
        } else {
          setDelayedIsOpen(false);
        }
        return () => {
          window.clearTimeout(delayedIsOpenTimeoutRef.current);
        };
      }, [isOpen]);
      const floatingOptions = react.useMemo(() => {
        const detectOverflowOptions = {
          padding: FLOATING_TOOLBAR_COLLISION_PADDING
        };
        return {
          strategy: "fixed",
          placement: position,
          middleware: [
            reactDom.inline(detectOverflowOptions),
            reactDom.flip({ ...detectOverflowOptions, crossAxis: false }),
            reactDom.hide(detectOverflowOptions),
            reactDom.shift({
              ...detectOverflowOptions,
              limiter: reactDom.limitShift()
            }),
            reactDom.offset(sideOffset),
            reactDom.size(detectOverflowOptions)
          ],
          whileElementsMounted: (...args) => {
            return reactDom.autoUpdate(...args, {
              animationFrame: true
            });
          }
        };
      }, [position, sideOffset]);
      const {
        refs: { setReference, setFloating },
        strategy,
        x,
        y,
        isPositioned
      } = reactDom.useFloating({
        ...floatingOptions,
        open: delayedIsOpen
      });
      const mergedRefs = _private.useRefs(forwardedRef, toolbarRef, setFloating);
      const handlePointerDown = react.useCallback(
        (event) => {
          onPointerDown?.(event);
          event.stopPropagation();
          if (event.target === toolbarRef.current) {
            event.preventDefault();
          }
        },
        [onPointerDown]
      );
      react.useEffect(() => {
        const handlePointerDown2 = () => {
          setPointerDown(true);
        };
        const handlePointerUp = () => {
          setPointerDown(false);
        };
        if (!root) {
          return;
        }
        root.addEventListener("pointerdown", handlePointerDown2);
        document.addEventListener("pointercancel", handlePointerUp);
        document.addEventListener("pointerup", handlePointerUp);
        return () => {
          root.removeEventListener("pointerdown", handlePointerDown2);
          document.removeEventListener("pointercancel", handlePointerUp);
          document.removeEventListener("pointerup", handlePointerUp);
        };
      }, [root]);
      react.useEffect(() => {
        const unregister = editor.registerUpdateListener(({ tags }) => {
          return editor.getEditorState().read(() => {
            if (tags.has("collaboration"))
              return;
            setManuallyClosed(false);
            const selection = lexical.$getSelection();
            if (!lexical.$isRangeSelection(selection) || selection.isCollapsed()) {
              setHasSelectionRange(false);
              setReference(null);
              return;
            }
            const { anchor, focus } = selection;
            const range = createDomRange.createDOMRange(
              editor,
              anchor.getNode(),
              anchor.offset,
              focus.getNode(),
              focus.offset
            );
            setHasSelectionRange(true);
            setReference(range);
          });
        });
        return unregister;
      }, [editor, setReference]);
      react.useEffect(() => {
        const root2 = editor.getRootElement();
        if (!root2 || !delayedIsOpen) {
          return;
        }
        const handleKeyDown = (event) => {
          if (event.target !== root2 && event.defaultPrevented) {
            return;
          }
          if (event.key === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            editor.focus();
            setManuallyClosed(true);
          }
        };
        root2.addEventListener("keydown", handleKeyDown);
        return () => {
          root2.removeEventListener("keydown", handleKeyDown);
        };
      }, [editor, delayedIsOpen]);
      const close = react.useCallback(() => {
        editor.focus();
        setManuallyClosed(true);
      }, [editor, setManuallyClosed]);
      const registerExternal = react.useCallback(
        (id) => {
          externalIds.add(id);
          return () => {
            externalIds.delete(id);
          };
        },
        [externalIds]
      );
      if (!delayedIsOpen) {
        return null;
      }
      const slotProps = { editor };
      return reactDom$1.createPortal(
        /* @__PURE__ */ jsxRuntime.jsx(_private.TooltipProvider, {
          children: /* @__PURE__ */ jsxRuntime.jsx(shared.FloatingToolbarContext.Provider, {
            value: { close, registerExternal },
            children: /* @__PURE__ */ jsxRuntime.jsxs("div", {
              role: "toolbar",
              "aria-label": "Floating toolbar",
              "aria-orientation": "horizontal",
              className: classnames.classNames(
                "lb-root lb-portal lb-elevation lb-lexical-floating-toolbar lb-lexical-toolbar",
                className
              ),
              ref: mergedRefs,
              style: {
                position: strategy,
                top: 0,
                left: 0,
                transform: isPositioned ? `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)` : "translate3d(0, -200%, 0)",
                minWidth: "max-content"
              },
              onPointerDown: handlePointerDown,
              onFocus: handleFocus,
              onBlur: handleBlur,
              ...props,
              children: [
                toolbar.applyToolbarSlot(before, slotProps),
                toolbar.applyToolbarSlot(children, slotProps),
                toolbar.applyToolbarSlot(after, slotProps)
              ]
            })
          })
        }),
        document.body
      );
    }
  ),
  {
    External: shared.FloatingToolbarExternal
  }
);

exports.FLOATING_TOOLBAR_COLLISION_PADDING = FLOATING_TOOLBAR_COLLISION_PADDING;
exports.FloatingToolbar = FloatingToolbar;
//# sourceMappingURL=floating-toolbar.js.map
