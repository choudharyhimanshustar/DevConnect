/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

"use strict";var e=require("lexical");function t(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var n=t((function(e){const t=new URLSearchParams;t.append("code",e);for(let e=1;e<arguments.length;e++)t.append("v",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));class l{constructor(e,t,n=1){this._offsetMap=e,this._firstNode=t,this._blockOffsetSize=n}createSelectionFromOffsets(t,n,l){const r=this._firstNode;if(null===r)return null;let i=t,f=n,c=o(r,i,this._blockOffsetSize),u=o(r,f,this._blockOffsetSize);if(void 0!==l&&(i=s(i,c,l,this,this._blockOffsetSize),c=o(r,i,this._blockOffsetSize),f=s(f,u,l,this,this._blockOffsetSize),u=o(r,f,this._blockOffsetSize)),null===c||null===u)return null;let a=c.key,d=u.key;const p=e.$getNodeByKey(a),g=e.$getNodeByKey(d);if(null===p||null===g)return null;let h=0,y=0,x="element",_="element";if("text"===c.type){h=i-c.start,x="text";const t=p.getNextSibling();i!==f&&h===p.getTextContentSize()&&e.$isTextNode(t)&&(h=0,a=t.__key)}else"inline"===c.type&&(a=p.getParentOrThrow().getKey(),h=f>c.start?c.end:c.start);"text"===u.type?(y=f-u.start,_="text"):"inline"===u.type&&(d=g.getParentOrThrow().getKey(),y=f>u.start?u.end:u.start);const v=e.$createRangeSelection();return null===v?null:(v.anchor.set(a,h,x),v.focus.set(d,y,_),v)}getOffsetsFromSelection(e){const t=e.anchor,n=e.focus,l=this._offsetMap,s=t.offset,o=n.offset;let r=-1,i=-1;if("text"===t.type){const e=l.get(t.key);void 0!==e&&(r=e.start+s)}else{const e=t.getNode().getDescendantByIndex(s);if(null!==e){const t=l.get(e.getKey());if(void 0!==t){r=e.getIndexWithinParent()!==s?t.end:t.start}}}if("text"===n.type){const e=l.get(n.key);void 0!==e&&(i=e.start+n.offset)}else{const e=n.getNode().getDescendantByIndex(o);if(null!==e){const t=l.get(e.getKey());if(void 0!==t){i=e.getIndexWithinParent()!==o?t.end:t.start}}}return[r,i]}}function s(e,t,n,l,s){const r=n._offsetMap,i=l._offsetMap,f=new Set;let c=e,u=t;for(;null!==u;){const e=u.key,t=r.get(e),n=u.end-u.start;if(f.add(e),void 0===t)c+=n;else{const e=t.end-t.start;e!==n&&(c+=n-e)}const l=u.prev;if(null!==l){u=l;continue}let s=u.parent;for(;null!==s;){let e=s.prev;if(null!==e){const t=e.key,n=r.get(t),l=e.end-e.start;if(f.add(t),void 0===n)c+=l;else{const e=n.end-n.start;e!==l&&(c+=l-e)}e=e.prev}s=s.parent}break}const a=n._firstNode;if(null!==a){u=o(a,e,s);let t=!1;for(;null!==u;){if(!f.has(u.key)){t=!0;break}u=u.parent}if(!t)for(;null!==u;){const e=u.key;if(!f.has(e)){const t=i.get(e),n=u.end-u.start;if(void 0===t)c-=n;else{const e=t.end-t.start;n!==e&&(c+=e-n)}}u=u.prev}}return c}function o(e,t,n){let l=e;for(;null!==l;){if(t<l.end+("element"!==l.type||0===n?1:0)){const e=l.child;if(null!==e){l=e;continue}return l}const e=l.next;if(null===e)break;l=e}return null}function r(e,t,n,l,s,o){return{child:e,end:l,key:s,next:null,parent:o,prev:null,start:n,type:t}}function i(t,l,s,o,i,u){const a=o.get(l);void 0===a&&n(3);const d=t.offset;if(e.$isElementNode(a)){const e=c(a,o),n=0===e.length,p=n?null:f(t,e,null,o,i,u);t.prevIsBlock&&!n||(t.prevIsBlock=!0,t.offset+=u);const g=r(p,"element",d,d,l,s);null!==p&&(p.parent=g);const h=t.offset;return g.end=h,i.set(l,g),g}t.prevIsBlock=!1;const p=e.$isTextNode(a),g=p?a.__text.length:1,h=r(null,p?"text":"inline",d,t.offset+=g,l,s);return i.set(l,h),h}function f(e,t,n,l,s,o){let r=null,f=null;const c=t.length;for(let u=0;u<c;u++){const c=i(e,t[u],n,l,s,o);null===f?r=c:(c.prev=f,f.next=c),f=c}return r}function c(t,l){const s=[];let o=t.__first;for(;null!==o;){const t=null===l?e.$getNodeByKey(o):l.get(o);null==t&&n(174),s.push(o),o=t.__next}return s}const u=c;exports.$createChildrenArray=c,exports.$createOffsetView=function(e,t=1,n){const s=(n||e._pendingEditorState||e._editorState)._nodeMap,o=s.get("root"),r=new Map,i=f({offset:0,prevIsBlock:!1},c(o,s),null,s,r,t);return new l(r,i,t)},exports.OffsetView=l,exports.createChildrenArray=u;
