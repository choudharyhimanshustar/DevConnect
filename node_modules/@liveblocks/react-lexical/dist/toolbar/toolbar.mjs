import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';
import { $isHeadingNode, $createHeadingNode, $createQuoteNode } from '@lexical/rich-text';
import { $setBlocksType } from '@lexical/selection';
import { mergeRegister } from '@lexical/utils';
import { ShortcutTooltip, Button, UndoIcon, RedoIcon, BoldIcon, ItalicIcon, UnderlineIcon, StrikethroughIcon, CodeIcon, CommentIcon, TextIcon, H1Icon, H2Icon, H3Icon, BlockquoteIcon, SelectButton, CheckIcon, TooltipProvider } from '@liveblocks/react-ui/_private';
import * as SelectPrimitive from '@radix-ui/react-select';
import * as TogglePrimitive from '@radix-ui/react-toggle';
import { CAN_UNDO_COMMAND, COMMAND_PRIORITY_CRITICAL, CAN_REDO_COMMAND, UNDO_COMMAND, REDO_COMMAND, FORMAT_TEXT_COMMAND, createCommand, $getSelection, $createParagraphNode, COMMAND_PRIORITY_LOW } from 'lexical';
import { forwardRef, useContext, useCallback, useState, useEffect, useMemo } from 'react';
import { classNames } from '../classnames.mjs';
import { OPEN_FLOATING_COMPOSER_COMMAND } from '../comments/floating-composer.mjs';
import { isBlockNodeActive } from '../is-block-node-active.mjs';
import { useIsCommandRegistered } from '../is-command-registered.mjs';
import { isTextFormatActive } from '../is-text-format-active.mjs';
import { FloatingToolbarContext, FloatingToolbarExternal } from './shared.mjs';

const BLOCK_SELECT_SIDE_OFFSET = 10;
const FLOATING_ELEMENT_COLLISION_PADDING = 10;
function applyToolbarSlot(slot, props) {
  if (typeof slot === "function") {
    const Component = slot;
    return /* @__PURE__ */ jsx(Component, {
      ...props
    });
  }
  return slot;
}
const ToolbarButton = forwardRef(
  ({ icon, children, name, shortcut, onKeyDown, ...props }, forwardedRef) => {
    const floatingToolbarContext = useContext(FloatingToolbarContext);
    const closeFloatingToolbar = floatingToolbarContext?.close;
    const handleKeyDown = useCallback(
      (event) => {
        onKeyDown?.(event);
        if (!event.isDefaultPrevented() && closeFloatingToolbar && event.key === "Escape") {
          closeFloatingToolbar();
          event.preventDefault();
          event.stopPropagation();
        }
      },
      [onKeyDown, closeFloatingToolbar]
    );
    return /* @__PURE__ */ jsx(ShortcutTooltip, {
      content: name,
      shortcut,
      children: /* @__PURE__ */ jsx(Button, {
        type: "button",
        variant: "toolbar",
        ref: forwardedRef,
        icon,
        "aria-label": !children ? name : void 0,
        ...props,
        onKeyDown: handleKeyDown,
        children: !children && !icon ? name : children
      })
    });
  }
);
const ToolbarToggle = forwardRef(
  ({ active, ...props }, forwardedRef) => {
    return /* @__PURE__ */ jsx(TogglePrimitive.Root, {
      asChild: true,
      pressed: active,
      children: /* @__PURE__ */ jsx(ToolbarButton, {
        ref: forwardedRef,
        ...props
      })
    });
  }
);
const ToolbarSeparator = forwardRef(
  ({ className, ...props }, forwardedRef) => {
    return /* @__PURE__ */ jsx("div", {
      ref: forwardedRef,
      role: "separator",
      "aria-orientation": "vertical",
      className: classNames("lb-lexical-toolbar-separator", className),
      ...props
    });
  }
);
function ToolbarSectionHistory() {
  const [editor] = useLexicalComposerContext();
  const [canUndo, setCanUndo] = useState(false);
  const [canRedo, setCanRedo] = useState(false);
  useEffect(() => {
    const unregister = mergeRegister(
      editor.registerCommand(
        CAN_UNDO_COMMAND,
        (payload) => {
          setCanUndo(payload);
          return false;
        },
        COMMAND_PRIORITY_CRITICAL
      ),
      editor.registerCommand(
        CAN_REDO_COMMAND,
        (payload) => {
          setCanRedo(payload);
          return false;
        },
        COMMAND_PRIORITY_CRITICAL
      )
    );
    return unregister;
  }, [editor]);
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [
      /* @__PURE__ */ jsx(ToolbarButton, {
        name: "Undo",
        icon: /* @__PURE__ */ jsx(UndoIcon, {}),
        shortcut: "Mod-Z",
        onClick: () => editor.dispatchCommand(UNDO_COMMAND, void 0),
        disabled: !canUndo
      }),
      /* @__PURE__ */ jsx(ToolbarButton, {
        name: "Redo",
        icon: /* @__PURE__ */ jsx(RedoIcon, {}),
        shortcut: "Mod-Shift-Z",
        onClick: () => editor.dispatchCommand(REDO_COMMAND, void 0),
        disabled: !canRedo
      })
    ]
  });
}
function ToolbarSectionInline() {
  const [editor] = useLexicalComposerContext();
  const supportsTextFormat = useIsCommandRegistered(FORMAT_TEXT_COMMAND);
  return supportsTextFormat ? /* @__PURE__ */ jsxs(Fragment, {
    children: [
      /* @__PURE__ */ jsx(ToolbarToggle, {
        name: "Bold",
        icon: /* @__PURE__ */ jsx(BoldIcon, {}),
        shortcut: "Mod-B",
        onClick: () => editor.dispatchCommand(FORMAT_TEXT_COMMAND, "bold"),
        active: isTextFormatActive(editor, "bold")
      }),
      /* @__PURE__ */ jsx(ToolbarToggle, {
        name: "Italic",
        icon: /* @__PURE__ */ jsx(ItalicIcon, {}),
        shortcut: "Mod-I",
        onClick: () => editor.dispatchCommand(FORMAT_TEXT_COMMAND, "italic"),
        active: isTextFormatActive(editor, "italic")
      }),
      /* @__PURE__ */ jsx(ToolbarToggle, {
        name: "Underline",
        icon: /* @__PURE__ */ jsx(UnderlineIcon, {}),
        shortcut: "Mod-U",
        onClick: () => editor.dispatchCommand(FORMAT_TEXT_COMMAND, "underline"),
        active: isTextFormatActive(editor, "underline")
      }),
      /* @__PURE__ */ jsx(ToolbarToggle, {
        name: "Strikethrough",
        icon: /* @__PURE__ */ jsx(StrikethroughIcon, {}),
        onClick: () => editor.dispatchCommand(FORMAT_TEXT_COMMAND, "strikethrough"),
        active: isTextFormatActive(editor, "strikethrough")
      }),
      /* @__PURE__ */ jsx(ToolbarToggle, {
        name: "Inline code",
        icon: /* @__PURE__ */ jsx(CodeIcon, {}),
        onClick: () => editor.dispatchCommand(FORMAT_TEXT_COMMAND, "code"),
        active: isTextFormatActive(editor, "code")
      })
    ]
  }) : null;
}
function ToolbarSectionCollaboration() {
  const [editor] = useLexicalComposerContext();
  const supportsThread = useIsCommandRegistered(OPEN_FLOATING_COMPOSER_COMMAND);
  return /* @__PURE__ */ jsx(Fragment, {
    children: supportsThread ? /* @__PURE__ */ jsx(ToolbarButton, {
      name: "Add a comment",
      icon: /* @__PURE__ */ jsx(CommentIcon, {}),
      onClick: () => editor.dispatchCommand(OPEN_FLOATING_COMPOSER_COMMAND, void 0),
      children: "Comment"
    }) : null
  });
}
function DefaultToolbarContent() {
  const supportsTextFormat = useIsCommandRegistered(FORMAT_TEXT_COMMAND);
  const supportsThread = useIsCommandRegistered(OPEN_FLOATING_COMPOSER_COMMAND);
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [
      /* @__PURE__ */ jsx(ToolbarSectionHistory, {}),
      supportsTextFormat ? /* @__PURE__ */ jsxs(Fragment, {
        children: [
          /* @__PURE__ */ jsx(ToolbarSeparator, {}),
          /* @__PURE__ */ jsx(ToolbarBlockSelector, {}),
          /* @__PURE__ */ jsx(ToolbarSectionInline, {})
        ]
      }) : null,
      supportsThread ? /* @__PURE__ */ jsxs(Fragment, {
        children: [
          /* @__PURE__ */ jsx(ToolbarSeparator, {}),
          /* @__PURE__ */ jsx(ToolbarSectionCollaboration, {})
        ]
      }) : null
    ]
  });
}
const INITIAL_COMMANDS_REGISTERED_COMMAND = createCommand(
  "INITIAL_COMMANDS_REGISTERED_COMMAND"
);
function useRerender() {
  const [, setRerender] = useState(false);
  return useCallback(() => {
    setRerender((toggle) => !toggle);
  }, [setRerender]);
}
function createDefaultBlockSelectorItems() {
  const items = [
    {
      name: "Text",
      icon: /* @__PURE__ */ jsx(TextIcon, {}),
      isActive: "default",
      setActive: () => $setBlocksType($getSelection(), () => $createParagraphNode())
    },
    {
      name: "Heading 1",
      icon: /* @__PURE__ */ jsx(H1Icon, {}),
      isActive: (editor) => {
        return isBlockNodeActive(
          editor,
          (node) => $isHeadingNode(node) ? node.getTag() === "h1" : false
        );
      },
      setActive: () => $setBlocksType($getSelection(), () => $createHeadingNode("h1"))
    },
    {
      name: "Heading 2",
      icon: /* @__PURE__ */ jsx(H2Icon, {}),
      isActive: (editor) => isBlockNodeActive(
        editor,
        (node) => $isHeadingNode(node) ? node.getTag() === "h2" : false
      ),
      setActive: () => $setBlocksType($getSelection(), () => $createHeadingNode("h2"))
    },
    {
      name: "Heading 3",
      icon: /* @__PURE__ */ jsx(H3Icon, {}),
      isActive: (editor) => isBlockNodeActive(
        editor,
        (node) => $isHeadingNode(node) ? node.getTag() === "h3" : false
      ),
      setActive: () => $setBlocksType($getSelection(), () => $createHeadingNode("h3"))
    },
    {
      name: "Blockquote",
      icon: /* @__PURE__ */ jsx(BlockquoteIcon, {}),
      isActive: (editor) => isBlockNodeActive(editor, (node) => node.getType() === "quote"),
      setActive: () => $setBlocksType($getSelection(), () => $createQuoteNode())
    }
  ];
  return items.filter(Boolean);
}
const ToolbarBlockSelector = forwardRef(({ items, onKeyDown, ...props }, forwardedRef) => {
  const floatingToolbarContext = useContext(FloatingToolbarContext);
  const closeFloatingToolbar = floatingToolbarContext?.close;
  const [editor] = useLexicalComposerContext();
  const resolvedItems = useMemo(() => {
    if (Array.isArray(items)) {
      return items;
    }
    const defaultItems = createDefaultBlockSelectorItems();
    return items ? items(defaultItems) : defaultItems;
  }, [items]);
  let defaultItem;
  let activeItem = resolvedItems.find((item) => {
    if (item.isActive === "default") {
      defaultItem = item;
      return false;
    }
    return item.isActive(editor);
  });
  if (!activeItem) {
    activeItem = defaultItem;
  }
  const handleItemChange = (name) => {
    const item = resolvedItems.find((item2) => item2.name === name);
    if (item) {
      editor.update(() => item.setActive(editor));
      floatingToolbarContext?.close();
    }
  };
  const handleKeyDown = useCallback(
    (event) => {
      onKeyDown?.(event);
      if (!event.isDefaultPrevented() && closeFloatingToolbar && event.key === "Escape") {
        closeFloatingToolbar();
        event.preventDefault();
        event.stopPropagation();
      }
    },
    [onKeyDown, closeFloatingToolbar]
  );
  return /* @__PURE__ */ jsxs(SelectPrimitive.Root, {
    value: activeItem?.name,
    onValueChange: handleItemChange,
    children: [
      /* @__PURE__ */ jsx(ShortcutTooltip, {
        content: "Turn into\u2026",
        children: /* @__PURE__ */ jsx(SelectPrimitive.Trigger, {
          asChild: true,
          ...props,
          ref: forwardedRef,
          onKeyDown: handleKeyDown,
          disabled: resolvedItems.length === 0,
          children: /* @__PURE__ */ jsx(SelectButton, {
            variant: "toolbar",
            children: activeItem?.name ?? "Turn into\u2026"
          })
        })
      }),
      /* @__PURE__ */ jsx(SelectPrimitive.Portal, {
        children: /* @__PURE__ */ jsx(FloatingToolbarExternal, {
          children: /* @__PURE__ */ jsx(SelectPrimitive.Content, {
            position: "popper",
            sideOffset: BLOCK_SELECT_SIDE_OFFSET,
            collisionPadding: FLOATING_ELEMENT_COLLISION_PADDING,
            className: "lb-root lb-portal lb-elevation lb-dropdown lb-select-dropdown lb-lexical-block-selector-dropdown",
            children: resolvedItems.map((item) => /* @__PURE__ */ jsxs(SelectPrimitive.Item, {
              value: item.name,
              className: "lb-dropdown-item",
              "data-name": item.name,
              children: [
                item.icon ? /* @__PURE__ */ jsx("span", {
                  className: "lb-dropdown-item-icon lb-icon-container",
                  children: item.icon
                }) : null,
                /* @__PURE__ */ jsx("span", {
                  className: "lb-dropdown-item-label",
                  children: item.label ?? item.name
                }),
                item.name === activeItem?.name ? /* @__PURE__ */ jsx("span", {
                  className: "lb-dropdown-item-accessory lb-icon-container",
                  children: /* @__PURE__ */ jsx(CheckIcon, {})
                }) : null
              ]
            }, item.name))
          })
        })
      })
    ]
  });
});
const Toolbar = Object.assign(
  forwardRef(
    ({ before, after, children = DefaultToolbarContent, className, ...props }, forwardedRef) => {
      const [editor] = useLexicalComposerContext();
      const [commandsRegistered, setCommandsRegistered] = useState(false);
      const rerender = useRerender();
      const slotProps = { editor };
      useEffect(() => {
        if (commandsRegistered) {
          return;
        }
        const unregister = editor.registerCommand(
          INITIAL_COMMANDS_REGISTERED_COMMAND,
          () => {
            setCommandsRegistered(true);
            return true;
          },
          COMMAND_PRIORITY_LOW
        );
        editor.dispatchCommand(INITIAL_COMMANDS_REGISTERED_COMMAND, void 0);
        return unregister;
      }, [editor, commandsRegistered]);
      useEffect(() => {
        const unregister = editor.registerUpdateListener(({ tags }) => {
          return editor.getEditorState().read(() => {
            if (tags.has("collaboration"))
              return;
            rerender();
          });
        });
        return unregister;
      }, [editor, rerender]);
      return /* @__PURE__ */ jsx(TooltipProvider, {
        children: /* @__PURE__ */ jsxs("div", {
          ref: forwardedRef,
          role: "toolbar",
          "aria-label": "Toolbar",
          "aria-orientation": "horizontal",
          className: classNames("lb-root lb-lexical-toolbar", className),
          ...props,
          children: [
            applyToolbarSlot(before, slotProps),
            applyToolbarSlot(children, slotProps),
            applyToolbarSlot(after, slotProps)
          ]
        })
      });
    }
  ),
  {
    Button: ToolbarButton,
    Toggle: ToolbarToggle,
    BlockSelector: ToolbarBlockSelector,
    Separator: ToolbarSeparator,
    SectionHistory: ToolbarSectionHistory,
    SectionInline: ToolbarSectionInline,
    SectionCollaboration: ToolbarSectionCollaboration
  }
);

export { BLOCK_SELECT_SIDE_OFFSET, FLOATING_ELEMENT_COLLISION_PADDING, Toolbar, applyToolbarSlot };
//# sourceMappingURL=toolbar.mjs.map
