'use strict';

var jsxRuntime = require('react/jsx-runtime');
var reactDom = require('@floating-ui/react-dom');
var LexicalComposerContext = require('@lexical/react/LexicalComposerContext');
var _private = require('@liveblocks/react/_private');
var reactUi = require('@liveblocks/react-ui');
var lexical = require('lexical');
var react = require('react');
var reactDom$1 = require('react-dom');
var classnames = require('../classnames.js');
var anchoredThreads = require('./anchored-threads.js');
var commentPluginProvider = require('./comment-plugin-provider.js');

function FloatingThreads({
  threads,
  components,
  ...props
}) {
  const activeThreads = useActiveThreads();
  const Thread = components?.Thread ?? reactUi.Thread;
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const nodes = useThreadToNodes();
  const [range, setRange] = react.useState(null);
  const handleUpdateRange = react.useCallback(() => {
    function getActiveRange() {
      function getActiveElements() {
        const activeElements2 = /* @__PURE__ */ new Set();
        for (const thread of activeThreads) {
          const keys = nodes.get(thread);
          if (keys === void 0)
            continue;
          for (const key of keys) {
            const element = editor.getElementByKey(key);
            if (element === null)
              continue;
            activeElements2.add(element);
          }
        }
        return activeElements2;
      }
      const activeElements = getActiveElements();
      const sortedElements = Array.from(activeElements).sort(anchoredThreads.compareNodes);
      if (sortedElements.length === 0)
        return null;
      const range3 = document.createRange();
      range3.setStartBefore(sortedElements[0]);
      range3.setEndAfter(sortedElements[sortedElements.length - 1]);
      return range3;
    }
    const active = (threads ?? []).filter(
      (thread) => activeThreads.includes(thread.id)
    );
    const range2 = getActiveRange();
    if (range2 === null) {
      setRange(null);
      return;
    }
    setRange({ range: range2, threads: active });
  }, [activeThreads, nodes, editor, threads]);
  react.useEffect(() => {
    handleUpdateRange();
  }, [handleUpdateRange]);
  react.useEffect(() => {
    return editor.registerUpdateListener(handleUpdateRange);
  }, [editor, handleUpdateRange]);
  const handleEscapeKeydown = react.useCallback(() => {
    if (range === null)
      return false;
    setRange(null);
    return true;
  }, [range]);
  react.useEffect(() => {
    return editor.registerCommand(
      lexical.KEY_ESCAPE_COMMAND,
      handleEscapeKeydown,
      lexical.COMMAND_PRIORITY_HIGH
    );
  }, [editor, handleEscapeKeydown]);
  const isCollapsed = useIsSelectionCollapsed();
  if (range === null || isCollapsed === null || !isCollapsed)
    return null;
  return /* @__PURE__ */ jsxRuntime.jsx(FloatingThreadPortal, {
    range: range.range,
    container: document.body,
    ...props,
    children: range.threads.map((thread) => /* @__PURE__ */ jsxRuntime.jsx(ThreadWrapper, {
      thread,
      Thread,
      onEscapeKeydown: handleEscapeKeydown,
      className: "lb-lexical-floating-threads-thread"
    }, thread.id))
  });
}
const FLOATING_THREAD_COLLISION_PADDING = 10;
function FloatingThreadPortal({
  container,
  range,
  children,
  className,
  style,
  ...props
}) {
  const {
    refs: { setReference, setFloating },
    strategy,
    x,
    y
  } = reactDom.useFloating({
    strategy: "absolute",
    placement: "bottom",
    middleware: [
      reactDom.flip({ padding: FLOATING_THREAD_COLLISION_PADDING, crossAxis: false }),
      reactDom.offset(10),
      reactDom.hide({ padding: FLOATING_THREAD_COLLISION_PADDING }),
      reactDom.shift({
        padding: FLOATING_THREAD_COLLISION_PADDING,
        limiter: reactDom.limitShift()
      }),
      reactDom.size({
        padding: FLOATING_THREAD_COLLISION_PADDING,
        apply({ availableWidth, availableHeight, elements }) {
          elements.floating.style.setProperty(
            "--lb-lexical-floating-threads-available-width",
            `${availableWidth}px`
          );
          elements.floating.style.setProperty(
            "--lb-lexical-floating-threads-available-height",
            `${availableHeight}px`
          );
        }
      })
    ],
    whileElementsMounted: (...args) => {
      return reactDom.autoUpdate(...args, {
        animationFrame: true
      });
    }
  });
  _private.useLayoutEffect(() => {
    setReference({
      getBoundingClientRect: () => range.getBoundingClientRect()
    });
  }, [setReference, range]);
  return reactDom$1.createPortal(
    /* @__PURE__ */ jsxRuntime.jsx("div", {
      ref: setFloating,
      ...props,
      style: {
        ...style,
        position: strategy,
        top: 0,
        left: 0,
        transform: `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`,
        minWidth: "max-content"
      },
      className: classnames.classNames(
        "lb-root lb-portal lb-elevation lb-lexical-floating lb-lexical-floating-threads",
        className
      ),
      children
    }),
    container
  );
}
function ThreadWrapper({
  thread,
  Thread,
  onEscapeKeydown,
  onKeyDown,
  ...threadProps
}) {
  const handleKeyDown = react.useCallback(
    (event) => {
      onKeyDown?.(event);
      if (event.key === "Escape") {
        onEscapeKeydown();
      }
    },
    [onEscapeKeydown, onKeyDown]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(Thread, {
    thread,
    onKeyDown: handleKeyDown,
    ...threadProps
  });
}
function useThreadToNodes() {
  const threadToNodes = react.useContext(commentPluginProvider.ThreadToNodesContext);
  if (threadToNodes === null) {
    throw new Error(
      "FloatingThreads component must be used within a LiveblocksPlugin component."
    );
  }
  return threadToNodes;
}
function useIsSelectionCollapsed() {
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const subscribe = react.useCallback(
    (onStoreChange) => {
      return editor.registerUpdateListener(onStoreChange);
    },
    [editor]
  );
  const getSnapshot = react.useCallback(() => {
    return editor.getEditorState().read(() => {
      const selection = lexical.$getSelection();
      if (selection === null)
        return null;
      return selection.isCollapsed();
    });
  }, [editor]);
  return react.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
function useActiveThreads() {
  const activeThreads = react.useContext(commentPluginProvider.ActiveThreadsContext);
  if (activeThreads === null) {
    throw new Error(
      "FloatingThreads component must be used within LiveblocksPlugin."
    );
  }
  return activeThreads;
}

exports.FLOATING_THREAD_COLLISION_PADDING = FLOATING_THREAD_COLLISION_PADDING;
exports.FloatingThreads = FloatingThreads;
//# sourceMappingURL=floating-threads.js.map
